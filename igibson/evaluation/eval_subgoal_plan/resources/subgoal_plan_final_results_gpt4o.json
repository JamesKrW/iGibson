{
    "assembling_gift_baskets": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: assembling_gift_baskets\n## Relevant objects in this scene\n{'name': 'basket.0', 'category': 'basket_n_01'}\n{'name': 'basket.1', 'category': 'basket_n_01'}\n{'name': 'basket.2', 'category': 'basket_n_01'}\n{'name': 'basket.3', 'category': 'basket_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'candle.0', 'category': 'candle_n_01'}\n{'name': 'candle.1', 'category': 'candle_n_01'}\n{'name': 'candle.2', 'category': 'candle_n_01'}\n{'name': 'candle.3', 'category': 'candle_n_01'}\n{'name': 'cookie.0', 'category': 'cookie_n_01'}\n{'name': 'cookie.1', 'category': 'cookie_n_01'}\n{'name': 'cookie.2', 'category': 'cookie_n_01'}\n{'name': 'cookie.3', 'category': 'cookie_n_01'}\n{'name': 'cheese.0', 'category': 'cheese_n_01'}\n{'name': 'cheese.1', 'category': 'cheese_n_01'}\n{'name': 'cheese.2', 'category': 'cheese_n_01'}\n{'name': 'cheese.3', 'category': 'cheese_n_01'}\n{'name': 'bow.0', 'category': 'bow_n_08'}\n{'name': 'bow.1', 'category': 'bow_n_08'}\n{'name': 'bow.2', 'category': 'bow_n_08'}\n{'name': 'bow.3', 'category': 'bow_n_08'}\n{'name': 'breakfast_table.13', 'category': 'table_n_02'}\n{'name': 'coffee_table.12', 'category': 'table_n_02'}\n\n## Initial States\nonfloor(basket.0, room_floor_living_room.0)\nonfloor(basket.1, room_floor_living_room.0)\nonfloor(basket.2, room_floor_living_room.0)\nonfloor(basket.3, room_floor_living_room.0)\nontop(candle.0, breakfast_table.13)\nontop(candle.1, breakfast_table.13)\nontop(candle.2, breakfast_table.13)\nontop(candle.3, breakfast_table.13)\nontop(cookie.0, breakfast_table.13)\nontop(cookie.1, breakfast_table.13)\nontop(cookie.2, breakfast_table.13)\nontop(cookie.3, breakfast_table.13)\nontop(cheese.0, coffee_table.12)\nontop(cheese.1, coffee_table.12)\nontop(cheese.2, coffee_table.12)\nontop(cheese.3, coffee_table.12)\nontop(bow.0, coffee_table.12)\nontop(bow.1, coffee_table.12)\nontop(bow.2, coffee_table.12)\nontop(bow.3, coffee_table.12)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforpairs(basket_n_01, candle_n_01, inside(candle_n_01, basket_n_01))\nforpairs(basket_n_01, cheese_n_01, inside(cheese_n_01, basket_n_01))\nforpairs(basket_n_01, cookie_n_01, inside(cookie_n_01, basket_n_01))\nforpairs(basket_n_01, bow_n_08, inside(bow_n_08, basket_n_01))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(candle.0)\", \"inside(candle.0, basket.0)\", \"holds_rh(candle.1)\", \"inside(candle.1, basket.1)\", \"holds_rh(candle.2)\", \"inside(candle.2, basket.2)\", \"holds_rh(candle.3)\", \"inside(candle.3, basket.3)\", \"holds_rh(cookie.0)\", \"inside(cookie.0, basket.0)\", \"holds_rh(cookie.1)\", \"inside(cookie.1, basket.1)\", \"holds_rh(cookie.2)\", \"inside(cookie.2, basket.2)\", \"holds_rh(cookie.3)\", \"inside(cookie.3, basket.3)\", \"holds_rh(cheese.0)\", \"inside(cheese.0, basket.0)\", \"holds_rh(cheese.1)\", \"inside(cheese.1, basket.1)\", \"holds_rh(cheese.2)\", \"inside(cheese.2, basket.2)\", \"holds_rh(cheese.3)\", \"inside(cheese.3, basket.3)\", \"holds_rh(bow.0)\", \"inside(bow.0, basket.0)\", \"holds_rh(bow.1)\", \"inside(bow.1, basket.1)\", \"holds_rh(bow.2)\", \"inside(bow.2, basket.2)\", \"holds_rh(bow.3)\", \"inside(bow.3, basket.3)\"]}"
    },
    "bottling_fruit": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: bottling_fruit\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}\n```"
    },
    "boxing_books_up_for_storage": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: boxing_books_up_for_storage\n## Relevant objects in this scene\n{'name': 'notebook.59', 'category': 'book_n_02'}\n{'name': 'notebook.60', 'category': 'book_n_02'}\n{'name': 'notebook.61', 'category': 'book_n_02'}\n{'name': 'notebook.62', 'category': 'book_n_02'}\n{'name': 'notebook.63', 'category': 'book_n_02'}\n{'name': 'hardback.64', 'category': 'book_n_02'}\n{'name': 'hardback.65', 'category': 'book_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'shelf.0', 'category': 'shelf_n_01'}\n{'name': 'carton.66', 'category': 'carton_n_02'}\n\n## Initial States\nonfloor(notebook.59, room_floor_living_room.0)\nonfloor(notebook.60, room_floor_living_room.0)\nonfloor(notebook.61, room_floor_living_room.0)\nonfloor(notebook.62, room_floor_living_room.0)\nonfloor(notebook.63, room_floor_living_room.0)\nontop(hardback.64, shelf.0)\nontop(hardback.65, shelf.0)\nonfloor(carton.66, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(book_n_02, inside(book_n_02, carton.66))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(notebook.59)\", \"inside(notebook.59, carton.66)\", \"holds_rh(notebook.60)\", \"inside(notebook.60, carton.66)\", \"holds_rh(notebook.61)\", \"inside(notebook.61, carton.66)\", \"holds_rh(notebook.62)\", \"inside(notebook.62, carton.66)\", \"holds_rh(notebook.63)\", \"inside(notebook.63, carton.66)\", \"holds_rh(hardback.64)\", \"inside(hardback.64, carton.66)\", \"holds_rh(hardback.65)\", \"inside(hardback.65, carton.66)\"]}"
    },
    "bringing_in_wood": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: bringing_in_wood\n## Relevant objects in this scene\n{'name': 'plywood.0', 'category': 'plywood_n_01'}\n{'name': 'plywood.1', 'category': 'plywood_n_01'}\n{'name': 'plywood.2', 'category': 'plywood_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nonfloor(plywood.0, room_floor_living_room.0)\nonfloor(plywood.1, room_floor_living_room.0)\nonfloor(plywood.2, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(plywood_n_01, onfloor(plywood_n_01, room_floor_kitchen.0))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(plywood.0)\", \"onfloor(plywood.0, room_floor_kitchen.0)\", \"holds_rh(plywood.1)\", \"onfloor(plywood.1, room_floor_kitchen.0)\", \"holds_rh(plywood.2)\", \"onfloor(plywood.2, room_floor_kitchen.0)\"]}"
    },
    "brushing_lint_off_clothing": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: brushing_lint_off_clothing\n## Relevant objects in this scene\n{'name': 'sweater.36', 'category': 'sweater_n_01'}\n{'name': 'sweater.37', 'category': 'sweater_n_01'}\n{'name': 'sweater.38', 'category': 'sweater_n_01'}\n{'name': 'sweater.39', 'category': 'sweater_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'bed.11', 'category': 'bed_n_01'}\n{'name': 'scrub_brush.40', 'category': 'scrub_brush_n_01'}\n\n## Initial States\nonfloor(sweater.36, room_floor_bedroom.0)\nonfloor(sweater.37, room_floor_bedroom.0)\nontop(sweater.38, bed.11)\nontop(sweater.39, bed.11)\ndusty(sweater.36)\ndusty(sweater.37)\ndusty(sweater.38)\ndusty(sweater.39)\nonfloor(scrub_brush.40, room_floor_bedroom.0)\nnot dusty(scrub_brush.40)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(sweater_n_01, (not dusty(sweater_n_01)))\nforall(sweater_n_01, ontop(sweater_n_01, bed.11))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(scrub_brush.40)\", \"not dusty(sweater.36) and not dusty(sweater.37) and not dusty(sweater.38) and not dusty(sweater.39)\", \"ontop(sweater.36, bed.11) and ontop(sweater.37, bed.11) and ontop(sweater.38, bed.11) and ontop(sweater.39, bed.11)\"]}\n```"
    },
    "chopping_vegetables": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: chopping_vegetables\n## Relevant objects in this scene\n{'name': 'tomato.61', 'category': 'tomato_n_01'}\n{'name': 'tomato.62', 'category': 'tomato_n_01'}\n{'name': 'mushroom.63', 'category': 'mushroom_n_05'}\n{'name': 'mushroom.64', 'category': 'mushroom_n_05'}\n{'name': 'chestnut.65', 'category': 'chestnut_n_03'}\n{'name': 'chestnut.66', 'category': 'chestnut_n_03'}\n{'name': 'countertop.26', 'category': 'countertop_n_01'}\n{'name': 'vidalia_onion.67', 'category': 'vidalia_onion_n_01'}\n{'name': 'vidalia_onion.68', 'category': 'vidalia_onion_n_01'}\n{'name': 'fridge.40', 'category': 'electric_refrigerator_n_01'}\n{'name': 'carving_knife.69', 'category': 'knife_n_01'}\n{'name': 'casserole.70', 'category': 'dish_n_01'}\n{'name': 'casserole.71', 'category': 'dish_n_01'}\n{'name': 'top_cabinet.50', 'category': 'cabinet_n_01'}\n{'name': 'sink.42', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(tomato.61, countertop.26)\nontop(tomato.62, countertop.26)\nontop(mushroom.63, countertop.26)\nontop(mushroom.64, countertop.26)\nontop(chestnut.65, countertop.26)\nontop(chestnut.66, countertop.26)\ninside(vidalia_onion.67, fridge.40)\ninside(vidalia_onion.68, fridge.40)\nontop(carving_knife.69, countertop.26)\ninside(casserole.70, top_cabinet.50)\ninside(casserole.71, top_cabinet.50)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(tomato_n_01, (exists(dish_n_01, inside(tomato_n_01, dish_n_01)) and sliced(tomato_n_01)))\nforall(mushroom_n_05, (exists(dish_n_01, inside(mushroom_n_05, dish_n_01)) and sliced(mushroom_n_05)))\nforall(chestnut_n_03, (exists(dish_n_01, inside(chestnut_n_03, dish_n_01)) and sliced(chestnut_n_03)))\nforall(vidalia_onion_n_01, (exists(dish_n_01, inside(vidalia_onion_n_01, dish_n_01)) and sliced(vidalia_onion_n_01)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(carving_knife.69)\", \"sliced(tomato.61) and sliced(tomato.62)\", \"sliced(mushroom.63) and sliced(mushroom.64)\", \"sliced(chestnut.65) and sliced(chestnut.66)\", \"ontop(vidalia_onion.67, countertop.26) and ontop(vidalia_onion.68, countertop.26)\", \"sliced(vidalia_onion.67) and sliced(vidalia_onion.68)\", \"inside(casserole.70, top_cabinet.50) and inside(casserole.71, top_cabinet.50)\", \"inside(tomato.61, casserole.70) and inside(tomato.62, casserole.70)\", \"inside(mushroom.63, casserole.70) and inside(mushroom.64, casserole.70)\", \"inside(chestnut.65, casserole.70) and inside(chestnut.66, casserole.70)\", \"inside(vidalia_onion.67, casserole.70) and inside(vidalia_onion.68, casserole.70)\"]}"
    },
    "cleaning_a_car": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_a_car\n## Relevant objects in this scene\n{'name': 'car.0', 'category': 'car_n_01'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'shelf.16', 'category': 'shelf_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'sink.38', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(car.0, room_floor_garage.0)\nontop(rag.0, shelf.16)\nnot soaked(rag.0)\nontop(soap.0, shelf.16)\ndusty(car.0)\nonfloor(bucket.0, room_floor_garage.0)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nnot dusty(car.0)\ninside(soap.0, bucket.0)\ninside(rag.0, bucket.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(rag.0)\", \"inside(rag.0, sink.38)\", \"toggledon(sink.38)\", \"soaked(rag.0)\", \"holds_rh(rag.0)\", \"not dusty(car.0)\", \"ontop(rag.0, shelf.16)\", \"holds_rh(soap.0)\", \"inside(soap.0, bucket.0)\", \"holds_rh(rag.0)\", \"inside(rag.0, bucket.0)\"]}\n```"
    },
    "cleaning_barbecue_grill": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_barbecue_grill\n## Relevant objects in this scene\n{'name': 'grill.50', 'category': 'grill_n_02'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'rag.51', 'category': 'rag_n_01'}\n{'name': 'bucket.52', 'category': 'bucket_n_01'}\n{'name': 'breakfast_table.14', 'category': 'table_n_02'}\n{'name': 'sink.32', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(grill.50, room_floor_garage.0)\nstained(grill.50)\ndusty(grill.50)\nontop(bucket.52, breakfast_table.14)\nontop(rag.51, breakfast_table.14)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nnot stained(grill.50)\nnot dusty(grill.50)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(rag.51)\", \"soaked(rag.51)\", \"not stained(grill.50)\", \"not dusty(grill.50)\"]}"
    },
    "cleaning_bathrooms": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_bathrooms\n## Relevant objects in this scene\n{'name': 'sink.7', 'category': 'sink_n_01'}\n{'name': 'bathtub.4', 'category': 'bathtub_n_01'}\n{'name': 'toilet.6', 'category': 'toilet_n_02'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'toothbrush.0', 'category': 'brush_n_02'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n\n## Initial States\nstained(sink.7)\nstained(bathtub.4)\nstained(toilet.6)\nstained(room_floor_bathroom.0)\ninside(soap.0, sink.7)\ninside(toothbrush.0, bathtub.4)\nonfloor(bucket.0, room_floor_bathroom.0)\nnot soaked(rag.0)\nonfloor(rag.0, room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnot stained(toilet.6)\nnot stained(bathtub.4)\nnot stained(sink.7)\nnot stained(room_floor_bathroom.0)\nsoaked(rag.0) and inside(rag.0, bucket.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(soap.0)\", \"not stained(toilet.6)\", \"not stained(bathtub.4)\", \"not stained(sink.7)\", \"holds_rh(rag.0)\", \"inside(rag.0, sink.7)\", \"toggledon(sink.7)\", \"soaked(rag.0)\", \"not stained(room_floor_bathroom.0)\", \"inside(rag.0, bucket.0)\"]}\n```"
    },
    "cleaning_bathtub": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_bathtub\n## Relevant objects in this scene\n{'name': 'sink.38', 'category': 'sink_n_01'}\n{'name': 'bathtub.35', 'category': 'bathtub_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'scrub_brush.0', 'category': 'scrub_brush_n_01'}\n\n## Initial States\nstained(bathtub.35)\nonfloor(soap.0, room_floor_bathroom.0)\nonfloor(bucket.0, room_floor_bathroom.0)\ninside(scrub_brush.0, bathtub.35)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnot stained(bathtub.35)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(scrub_brush.0)\", \"not stained(bathtub.35)\"]}"
    },
    "cleaning_bedroom": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_bedroom\n## Relevant objects in this scene\n{'name': 'room_floor_bedroom.1', 'category': 'floor_n_01'}\n{'name': 'jeans.46', 'category': 'apparel_n_01'}\n{'name': 'jeans.47', 'category': 'apparel_n_01'}\n{'name': 'bed.10', 'category': 'bed_n_01'}\n{'name': 'necklace.48', 'category': 'jewelry_n_01'}\n{'name': 'cologne.49', 'category': 'perfume_n_02'}\n{'name': 'painting.50', 'category': 'painting_n_01'}\n{'name': 'vacuum.51', 'category': 'vacuum_n_04'}\n{'name': 'hand_towel.52', 'category': 'hand_towel_n_01'}\n{'name': 'sheet.53', 'category': 'sheet_n_03'}\n{'name': 'bottom_cabinet.2', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.0', 'category': 'cabinet_n_01'}\n\n## Initial States\ndusty(bottom_cabinet.2)\ndusty(bottom_cabinet.0)\nontop(jeans.46, bed.10)\nontop(jeans.47, bed.10)\nonfloor(necklace.48, room_floor_bedroom.1)\nonfloor(cologne.49, room_floor_bedroom.1)\nontop(painting.50, bed.10)\nnot dusty(vacuum.51)\nonfloor(vacuum.51, room_floor_bedroom.1)\nonfloor(hand_towel.52, room_floor_bedroom.1)\nonfloor(sheet.53, room_floor_bedroom.1)\nonfloor(agent_n_01.1, room_floor_bedroom.1)\n\n## Goal States\nforall(apparel_n_01, exists(cabinet_n_01, inside(apparel_n_01, cabinet_n_01)))\ninside(necklace.48, bottom_cabinet.2) and inside(cologne.49, bottom_cabinet.2)\nontop(sheet.53, bed.10)\nforall(cabinet_n_01, (not dusty(cabinet_n_01)))\nnextto(vacuum.51, bed.10)\nontop(painting.50, sheet.53)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(hand_towel.52)\", \"not dusty(bottom_cabinet.2) and not dusty(bottom_cabinet.0)\", \"holds_rh(hand_towel.52) and onfloor(hand_towel.52, room_floor_bedroom.1)\", \"holds_rh(jeans.46)\", \"inside(jeans.46, bottom_cabinet.0)\", \"holds_rh(jeans.47)\", \"inside(jeans.47, bottom_cabinet.0)\", \"holds_rh(necklace.48)\", \"inside(necklace.48, bottom_cabinet.2)\", \"holds_rh(cologne.49)\", \"inside(cologne.49, bottom_cabinet.2)\", \"holds_rh(sheet.53)\", \"ontop(sheet.53, bed.10)\", \"holds_rh(painting.50)\", \"ontop(painting.50, sheet.53)\", \"nextto(vacuum.51, bed.10)\"]}"
    },
    "cleaning_carpets": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_carpets\n## Relevant objects in this scene\n{'name': 'room_floor_corridor.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_utility_room.0', 'category': 'floor_n_01'}\n{'name': 'hand_towel.102', 'category': 'hand_towel_n_01'}\n{'name': 'shampoo.103', 'category': 'shampoo_n_01'}\n{'name': 'top_cabinet.50', 'category': 'cabinet_n_01'}\n{'name': 'washer.49', 'category': 'washer_n_03'}\n{'name': 'dryer.48', 'category': 'dryer_n_01'}\n{'name': 'door.80', 'category': 'door_n_01'}\n{'name': 'sink.51', 'category': 'sink_n_01'}\n\n## Initial States\nstained(room_floor_corridor.0)\nonfloor(hand_towel.102, room_floor_utility_room.0)\ninside(shampoo.103, top_cabinet.50)\nonfloor(agent_n_01.1, room_floor_corridor.0)\n\n## Goal States\nnot stained(room_floor_corridor.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n  \"output\": [\n    \"open(top_cabinet.50)\", \n    \"holds_rh(shampoo.103)\", \n    \"holds_lh(hand_towel.102)\", \n    \"soaked(hand_towel.102)\", \n    \"not stained(room_floor_corridor.0)\"\n  ]\n}"
    },
    "cleaning_closet": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_closet\n## Relevant objects in this scene\n{'name': 'shelf.31', 'category': 'shelf_n_01'}\n{'name': 'bottom_cabinet.44', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.1', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.30', 'category': 'cabinet_n_01'}\n{'name': 'bracelet.0', 'category': 'jewelry_n_01'}\n{'name': 'necklace.0', 'category': 'jewelry_n_01'}\n{'name': 'room_floor_closet.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'hat.0', 'category': 'hat_n_01'}\n{'name': 'sandal.0', 'category': 'sandal_n_01'}\n{'name': 'sandal.1', 'category': 'sandal_n_01'}\n{'name': 'umbrella.0', 'category': 'umbrella_n_01'}\n{'name': 'paper_towel.0', 'category': 'towel_n_01'}\n\n## Initial States\ndusty(shelf.31)\ndusty(bottom_cabinet.30)\nonfloor(bracelet.0, room_floor_closet.0)\nonfloor(necklace.0, room_floor_closet.0)\ndusty(room_floor_closet.0)\nonfloor(hat.0, room_floor_closet.0)\nonfloor(sandal.0, room_floor_closet.0)\nonfloor(sandal.1, room_floor_closet.0)\nonfloor(umbrella.0, room_floor_closet.0)\ninside(paper_towel.0, bottom_cabinet.44)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(jewelry_n_01, inside(jewelry_n_01, bottom_cabinet.30))\nnot inside(umbrella.0, bottom_cabinet.30)\ninside(hat.0, bottom_cabinet.44) or ontop(hat.0, shelf.31)\nforall(sandal_n_01, (nextto(sandal_n_01, shelf.31) and onfloor(sandal_n_01, room_floor_closet.0)))\nnot dusty(bottom_cabinet.30)\nnot dusty(shelf.31)\nnot dusty(room_floor_closet.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"ontop(agent_n_01.1, room_floor_closet.0)\", \"holds_rh(paper_towel.0)\", \"not dusty(shelf.31) and not dusty(bottom_cabinet.30) and not dusty(room_floor_closet.0)\", \"holds_rh(bracelet.0)\", \"inside(bracelet.0, bottom_cabinet.30)\", \"holds_rh(necklace.0)\", \"inside(necklace.0, bottom_cabinet.30)\", \"holds_rh(hat.0)\", \"ontop(hat.0, shelf.31) or inside(hat.0, bottom_cabinet.44)\", \"holds_rh(sandal.0)\", \"nextto(sandal.0, shelf.31) and onfloor(sandal.0, room_floor_closet.0)\", \"holds_rh(sandal.1)\", \"nextto(sandal.1, shelf.31) and onfloor(sandal.1, room_floor_closet.0)\"]}"
    },
    "cleaning_cupboards": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_cupboards\n## Relevant objects in this scene\n{'name': 'notebook.102', 'category': 'book_n_02'}\n{'name': 'hardback.103', 'category': 'book_n_02'}\n{'name': 'hardback.104', 'category': 'book_n_02'}\n{'name': 'bottom_cabinet.28', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.25', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.24', 'category': 'cabinet_n_01'}\n{'name': 'pen.105', 'category': 'pen_n_01'}\n{'name': 'highlighter.106', 'category': 'marker_n_03'}\n{'name': 'highlighter.107', 'category': 'marker_n_03'}\n{'name': 'screwdriver.108', 'category': 'screwdriver_n_01'}\n{'name': 'scrub_brush.109', 'category': 'scrub_brush_n_01'}\n{'name': 'rag.110', 'category': 'rag_n_01'}\n{'name': 'detergent.111', 'category': 'cleansing_agent_n_01'}\n{'name': 'trash_can.112', 'category': 'bin_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'bucket.113', 'category': 'bucket_n_01'}\n{'name': 'bed.58', 'category': 'bed_n_01'}\n\n## Initial States\ninside(notebook.102, bottom_cabinet.28)\ninside(hardback.103, bottom_cabinet.25)\ninside(hardback.104, bottom_cabinet.25)\ninside(pen.105, bottom_cabinet.28)\ninside(highlighter.106, bottom_cabinet.25)\ninside(highlighter.107, bottom_cabinet.25)\ninside(screwdriver.108, bottom_cabinet.24)\ninside(scrub_brush.109, bottom_cabinet.28)\ninside(rag.110, bottom_cabinet.28)\nontop(detergent.111, bed.58)\nonfloor(trash_can.112, room_floor_bedroom.0)\nontop(bucket.113, bed.58)\ndusty(bottom_cabinet.28)\ndusty(bottom_cabinet.25)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(cabinet_n_01, (not dusty(cabinet_n_01)))\nforall(book_n_02, forall(cabinet_n_01, (not inside(book_n_02, cabinet_n_01))))\ninside(screwdriver.108, trash_can.112)\nforall(marker_n_03, inside(marker_n_03, bucket.113))\ninside(pen.105, bucket.113)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holding (detergent.111)\", \"inside(detergent.111, bottom_cabinet.28)\", \"not dusty(bottom_cabinet.28)\", \"inside(detergent.111, bottom_cabinet.25)\", \"not dusty(bottom_cabinet.25)\", \"inside(notebook.102, bucket.113)\", \"inside(hardback.103, bucket.113)\", \"inside(hardback.104, bucket.113)\", \"inside(highlighter.106, bucket.113)\", \"inside(highlighter.107, bucket.113)\", \"inside(pen.105, bucket.113)\", \"inside(screwdriver.108, trash_can.112)\"]}\n```"
    },
    "cleaning_floors": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_floors\n## Relevant objects in this scene\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'broom.0', 'category': 'broom_n_01'}\n{'name': 'dustpan.0', 'category': 'dustpan_n_02'}\n{'name': 'toothpaste.0', 'category': 'cleansing_agent_n_01'}\n{'name': 'scrub_brush.0', 'category': 'scrub_brush_n_01'}\n{'name': 'door.65', 'category': 'door_n_01'}\n{'name': 'sink.48', 'category': 'sink_n_01'}\n\n## Initial States\ndusty(room_floor_bathroom.0)\nstained(room_floor_bathroom.0)\nonfloor(broom.0, room_floor_bathroom.0)\nonfloor(dustpan.0, room_floor_bathroom.0)\nonfloor(toothpaste.0, room_floor_bathroom.0)\nonfloor(scrub_brush.0, room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnot stained(room_floor_bathroom.0)\nnot dusty(room_floor_bathroom.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(broom.0)\", \"not dusty(room_floor_bathroom.0)\", \"holds_rh(scrub_brush.0)\", \"soaked(scrub_brush.0)\", \"not stained(room_floor_bathroom.0)\"]}\n```"
    },
    "cleaning_freezer": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_freezer\n## Relevant objects in this scene\n{'name': 'fridge.20', 'category': 'electric_refrigerator_n_01'}\n{'name': 'pop.0', 'category': 'food_n_01'}\n{'name': 'pop.1', 'category': 'food_n_01'}\n{'name': 'pop.2', 'category': 'food_n_01'}\n{'name': 'toothpaste.0', 'category': 'cleansing_agent_n_01'}\n{'name': 'breakfast_table.6', 'category': 'table_n_02'}\n{'name': 'hand_towel.0', 'category': 'towel_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'countertop.31', 'category': 'countertop_n_01'}\n{'name': 'burner.64', 'category': 'stove_n_01'}\n{'name': 'door.70', 'category': 'door_n_01'}\n{'name': 'straight_chair.7', 'category': 'chair_n_01'}\n\n## Initial States\nstained(fridge.20)\ninside(pop.0, fridge.20)\ninside(pop.1, fridge.20)\ninside(pop.2, fridge.20)\nontop(toothpaste.0, breakfast_table.6)\nontop(hand_towel.0, breakfast_table.6)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnot stained(fridge.20)\nforall(food_n_01, (not inside(food_n_01, fridge.20)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"open(fridge.20)\", \"holds_rh(pop.0)\", \"ontop(pop.0, countertop.31)\", \"holds_rh(pop.1)\", \"ontop(pop.1, countertop.31)\", \"holds_rh(pop.2)\", \"ontop(pop.2, countertop.31)\", \"holds_rh(hand_towel.0)\", \"soaked(hand_towel.0)\", \"not stained(fridge.20)\"]}\n```"
    },
    "cleaning_garage": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_garage\n## Relevant objects in this scene\n{'name': 'carton.0', 'category': 'box_n_01'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_storage_room.0', 'category': 'floor_n_01'}\n{'name': 'newspaper.0', 'category': 'newspaper_n_03'}\n{'name': 'newspaper.1', 'category': 'newspaper_n_03'}\n{'name': 'cruet.0', 'category': 'bottle_n_01'}\n{'name': 'cruet.1', 'category': 'bottle_n_01'}\n{'name': 'bottom_cabinet.15', 'category': 'cabinet_n_01'}\n{'name': 'broom.0', 'category': 'broom_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'breakfast_table.14', 'category': 'table_n_02'}\n{'name': 'trash_can.0', 'category': 'bin_n_01'}\n{'name': 'sink.32', 'category': 'sink_n_01'}\n{'name': 'shelf.23', 'category': 'shelf_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_garage.0)\nonfloor(newspaper.0, room_floor_garage.0)\nonfloor(newspaper.1, room_floor_garage.0)\nonfloor(cruet.0, room_floor_garage.0)\nonfloor(cruet.1, room_floor_garage.0)\ndusty(room_floor_garage.0)\nstained(room_floor_garage.0)\ndusty(bottom_cabinet.15)\nonfloor(broom.0, room_floor_garage.0)\nontop(rag.0, breakfast_table.14)\nonfloor(trash_can.0, room_floor_garage.0)\nonfloor(agent_n_01.1, room_floor_storage_room.0)\n\n## Goal States\nnot dusty(room_floor_garage.0)\nnot dusty(bottom_cabinet.15)\nnot stained(bottom_cabinet.15)\nforall(newspaper_n_03, (inside(newspaper_n_03, trash_can.0) or (not onfloor(newspaper_n_03, room_floor_garage.0))))\nforall(bottle_n_01, ontop(bottle_n_01, breakfast_table.14))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"onfloor(agent_n_01.1, room_floor_garage.0)\", \"holds_rh(broom.0)\", \"not dusty(room_floor_garage.0)\", \"ontop(broom.0, room_floor_garage.0) and ontop(rag.0, room_floor_garage.0)\", \"holds_rh(rag.0)\", \"not stained(room_floor_garage.0)\", \"not dusty(bottom_cabinet.15)\", \"holds_lh(newspaper.0)\", \"inside(newspaper.0, trash_can.0)\", \"holds_lh(newspaper.1)\", \"inside(newspaper.1, trash_can.0)\", \"holds_lh(cruet.0)\", \"ontop(cruet.0, breakfast_table.14)\", \"holds_lh(cruet.1)\", \"ontop(cruet.1, breakfast_table.14)\"]}"
    },
    "cleaning_high_chair": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_high_chair\n## Relevant objects in this scene\n{'name': 'highchair.0', 'category': 'highchair_n_01'}\n{'name': 'paper_towel.0', 'category': 'piece_of_cloth_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'sink.82', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n\n## Initial States\ndusty(highchair.0)\ninside(paper_towel.0, bottom_cabinet_no_top.80)\nonfloor(highchair.0, room_floor_dining_room.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnot dusty(highchair.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet_no_top.80)\", \"holds_rh(paper_towel.0)\", \"not dusty(highchair.0)\"]}"
    },
    "cleaning_kitchen_cupboard": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_kitchen_cupboard\n## Relevant objects in this scene\n{'name': 'top_cabinet.25', 'category': 'cabinet_n_01'}\n{'name': 'top_cabinet.24', 'category': 'cabinet_n_01'}\n{'name': 'countertop.31', 'category': 'countertop_n_01'}\n{'name': 'paper_towel.0', 'category': 'piece_of_cloth_n_01'}\n{'name': 'soap.0', 'category': 'cleansing_agent_n_01'}\n{'name': 'bowl.0', 'category': 'bowl_n_01'}\n{'name': 'bowl.1', 'category': 'bowl_n_01'}\n{'name': 'cup.0', 'category': 'cup_n_01'}\n{'name': 'cup.1', 'category': 'cup_n_01'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ndusty(top_cabinet.25)\ndusty(top_cabinet.24)\nontop(paper_towel.0, countertop.31)\nontop(soap.0, countertop.31)\ninside(bowl.1, top_cabinet.24)\ninside(cup.0, top_cabinet.24)\ninside(cup.1, top_cabinet.25)\nontop(bowl.0, countertop.31)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(cabinet_n_01, (not dusty(cabinet_n_01)))\nexists(cabinet_n_01, forall(bowl_n_01, (inside(bowl_n_01, cabinet_n_01) and (not inside(cup.0, cabinet_n_01)))))\nexists(cabinet_n_01, forall(cup_n_01, (inside(cup_n_01, cabinet_n_01) and (not inside(bowl.0, cabinet_n_01)))))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(paper_towel.0)\", \"holds_rh(soap.0)\", \"not dusty(top_cabinet.25) and not dusty(top_cabinet.24)\", \"ontop(bowl.0, countertop.31)\", \"ontop(bowl.0, countertop.31) and ontop(bowl.0, countertop.31) and ontop(bowl.0, countertop.31) and ontop(bowl.0, countertop.31)\", \"inside(bowl.1, top_cabinet.24) and not inside(cup.0, top_cabinet.24)\", \"inside(cup.0, top_cabinet.24) and not inside(bowl.0, top_cabinet.24)\", \"inside(cup.1, top_cabinet.25) and not inside(bowl.0, top_cabinet.25)\"]}\n```"
    },
    "cleaning_microwave_oven": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_microwave_oven\n## Relevant objects in this scene\n{'name': 'microwave.36', 'category': 'microwave_n_02'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'countertop.18', 'category': 'countertop_n_01'}\n{'name': 'trash_can.0', 'category': 'ashcan_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'bottom_cabinet_no_top.15', 'category': 'cabinet_n_01'}\n{'name': 'sink.19', 'category': 'sink_n_01'}\n\n## Initial States\ndusty(microwave.36)\nstained(microwave.36)\nontop(rag.0, countertop.18)\nonfloor(trash_can.0, room_floor_kitchen.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnot dusty(microwave.36)\nnot stained(microwave.36)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(rag.0)\", \"inside(rag.0, sink.19) and toggledon(sink.19)\", \"soaked(rag.0)\", \"holds_rh(rag.0)\", \"not dusty(microwave.36) and not stained(microwave.36)\"]}\n```"
    },
    "cleaning_out_drawers": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_out_drawers\n## Relevant objects in this scene\n{'name': 'bowl.0', 'category': 'bowl_n_01'}\n{'name': 'bowl.1', 'category': 'bowl_n_01'}\n{'name': 'bottom_cabinet_no_top.16', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet_no_top.15', 'category': 'cabinet_n_01'}\n{'name': 'spoon.0', 'category': 'spoon_n_01'}\n{'name': 'spoon.1', 'category': 'spoon_n_01'}\n{'name': 'bath_towel.0', 'category': 'piece_of_cloth_n_01'}\n{'name': 'sink.19', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(bowl.0, bottom_cabinet_no_top.16)\ninside(bowl.1, bottom_cabinet_no_top.16)\ninside(spoon.0, bottom_cabinet_no_top.15)\ninside(spoon.1, bottom_cabinet_no_top.15)\ninside(bath_towel.0, bottom_cabinet_no_top.16)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnextto(bath_towel.0, sink.19)\nnextto(bowl.0, sink.19)\nnextto(bowl.1, sink.19)\nnextto(spoon.0, sink.19)\nnextto(spoon.1, sink.19)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n    \"output\": [\n        \"open(bottom_cabinet_no_top.16) and open(bottom_cabinet_no_top.15)\",\n        \"holds_rh(bowl.0)\",\n        \"nextto(bowl.0, sink.19)\",\n        \"holds_rh(bowl.1)\",\n        \"nextto(bowl.1, sink.19)\",\n        \"holds_rh(spoon.0)\",\n        \"nextto(spoon.0, sink.19)\",\n        \"holds_rh(spoon.1)\",\n        \"nextto(spoon.1, sink.19)\",\n        \"holds_rh(bath_towel.0)\",\n        \"nextto(bath_towel.0, sink.19)\"\n    ]\n}"
    },
    "cleaning_oven": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_oven\n## Relevant objects in this scene\n{'name': 'dustpan.0', 'category': 'receptacle_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'bottom_cabinet_no_top.15', 'category': 'cabinet_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'rag.1', 'category': 'rag_n_01'}\n{'name': 'newspaper.0', 'category': 'newspaper_n_03'}\n{'name': 'sink.19', 'category': 'sink_n_01'}\n{'name': 'scrub_brush.0', 'category': 'scrub_brush_n_01'}\n{'name': 'oven.24', 'category': 'oven_n_01'}\n\n## Initial States\nonfloor(dustpan.0, room_floor_kitchen.0)\ninside(soap.0, bottom_cabinet_no_top.15)\ninside(rag.0, bottom_cabinet_no_top.15)\ninside(rag.1, bottom_cabinet_no_top.15)\nnot soaked(rag.0)\nnot soaked(rag.1)\nonfloor(newspaper.0, room_floor_kitchen.0)\ninside(scrub_brush.0, bottom_cabinet_no_top.15)\nnot soaked(scrub_brush.0)\nstained(oven.24)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(rag_n_01, soaked(rag_n_01))\nsoaked(scrub_brush.0)\nnot stained(oven.24)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet_no_top.15)\", \"holds_rh(rag.0)\", \"inside(rag.0, sink.19)\", \"toggledon(sink.19)\", \"soaked(rag.0)\", \"holds_rh(rag.1)\", \"inside(rag.1, sink.19)\", \"soaked(rag.1)\", \"holds_rh(scrub_brush.0)\", \"inside(scrub_brush.0, sink.19)\", \"soaked(scrub_brush.0)\", \"not stained(oven.24)\"]}"
    },
    "cleaning_shoes": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_shoes\n## Relevant objects in this scene\n{'name': 'soap.36', 'category': 'soap_n_01'}\n{'name': 'bed.11', 'category': 'bed_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'rag.37', 'category': 'rag_n_01'}\n{'name': 'paper_towel.38', 'category': 'towel_n_01'}\n{'name': 'sandal.39', 'category': 'shoe_n_01'}\n{'name': 'sandal.40', 'category': 'shoe_n_01'}\n{'name': 'sandal.41', 'category': 'shoe_n_01'}\n{'name': 'walker.42', 'category': 'shoe_n_01'}\n{'name': 'sink.18', 'category': 'sink_n_01'}\n\n## Initial States\nontop(soap.36, bed.11)\nontop(rag.37, bed.11)\nonfloor(paper_towel.38, room_floor_bedroom.0)\nontop(sandal.39, bed.11)\nontop(sandal.40, bed.11)\nontop(sandal.41, bed.11)\nontop(walker.42, bed.11)\nstained(sandal.39)\nstained(sandal.40)\ndusty(sandal.41)\ndusty(walker.42)\nnot soaked(rag.37)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(shoe_n_01, (not stained(shoe_n_01)))\nforall(shoe_n_01, (not dusty(shoe_n_01)))\nonfloor(paper_towel.38, room_floor_bedroom.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(rag.37)\", \"soaked(rag.37)\", \"not stained(sandal.39) and not stained(sandal.40)\", \"not dusty(sandal.41) and not dusty(walker.42)\", \"onfloor(paper_towel.38, room_floor_bedroom.0)\"]}"
    },
    "cleaning_sneakers": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_sneakers\n## Relevant objects in this scene\n{'name': 'gym_shoe.78', 'category': 'gym_shoe_n_01'}\n{'name': 'gym_shoe.79', 'category': 'gym_shoe_n_01'}\n{'name': 'gym_shoe.80', 'category': 'gym_shoe_n_01'}\n{'name': 'gym_shoe.81', 'category': 'gym_shoe_n_01'}\n{'name': 'countertop.31', 'category': 'countertop_n_01'}\n{'name': 'soap.82', 'category': 'soap_n_01'}\n{'name': 'top_cabinet.24', 'category': 'cabinet_n_01'}\n{'name': 'hand_towel.83', 'category': 'towel_n_01'}\n{'name': 'scrub_brush.84', 'category': 'brush_n_02'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'coffee_table.4', 'category': 'table_n_02'}\n\n## Initial States\nonfloor(gym_shoe.78, room_floor_kitchen.0)\nstained(gym_shoe.78)\nonfloor(gym_shoe.79, room_floor_kitchen.0)\nstained(gym_shoe.79)\nonfloor(gym_shoe.80, room_floor_kitchen.0)\ndusty(gym_shoe.80)\nonfloor(gym_shoe.81, room_floor_kitchen.0)\ndusty(gym_shoe.81)\ninside(soap.82, top_cabinet.24)\nontop(hand_towel.83, countertop.31)\nnot stained(hand_towel.83)\nontop(scrub_brush.84, countertop.31)\nnot stained(scrub_brush.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nontop(hand_towel.83, countertop.31)\nnextto(scrub_brush.84, hand_towel.83)\ninside(soap.82, sink.37)\nforall(gym_shoe_n_01, (not dusty(gym_shoe_n_01)))\nforall(gym_shoe_n_01, (not stained(gym_shoe_n_01)))\nforn(2, gym_shoe_n_01, nextto(gym_shoe_n_01, coffee_table.4))\nforn(2, gym_shoe_n_01, under(gym_shoe_n_01, coffee_table.4))\nforall(gym_shoe_n_01, onfloor(gym_shoe_n_01, room_floor_living_room.0))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(gym_shoe.78) and holds_lh(scrub_brush.84)\", \"not stained(gym_shoe.78)\", \"onfloor(gym_shoe.78, room_floor_kitchen.0)\", \"holds_rh(gym_shoe.79) and holds_lh(scrub_brush.84)\", \"not stained(gym_shoe.79)\", \"onfloor(gym_shoe.79, room_floor_kitchen.0)\", \"holds_rh(gym_shoe.80) and holds_lh(hand_towel.83)\", \"not dusty(gym_shoe.80)\", \"onfloor(gym_shoe.80, room_floor_kitchen.0)\", \"holds_rh(gym_shoe.81) and holds_lh(hand_towel.83)\", \"not dusty(gym_shoe.81)\", \"onfloor(gym_shoe.81, room_floor_kitchen.0)\", \"holds_rh(soap.82)\", \"inside(soap.82, sink.37)\", \"ontop(hand_towel.83, countertop.31)\", \"nextto(scrub_brush.84, hand_towel.83)\", \"holds_rh(gym_shoe.78)\", \"onfloor(gym_shoe.78, room_floor_living_room.0)\", \"holds_rh(gym_shoe.79)\", \"onfloor(gym_shoe.79, room_floor_living_room.0)\", \"holds_rh(gym_shoe.80)\", \"onfloor(gym_shoe.80, room_floor_living_room.0)\", \"holds_rh(gym_shoe.81)\", \"onfloor(gym_shoe.81, room_floor_living_room.0)\", \"nextto(gym_shoe.78, coffee_table.4)\", \"nextto(gym_shoe.79, coffee_table.4)\", \"under(gym_shoe.80, coffee_table.4)\", \"under(gym_shoe.81, coffee_table.4)\"]}\n```"
    },
    "cleaning_stove": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_stove\n## Relevant objects in this scene\n{'name': 'stove.88', 'category': 'stove_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'sink.82', 'category': 'sink_n_01'}\n{'name': 'dishtowel.0', 'category': 'dishtowel_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ndusty(stove.88)\nstained(stove.88)\ninside(soap.0, bottom_cabinet_no_top.80)\ninside(rag.0, bottom_cabinet_no_top.80)\nnot soaked(rag.0)\nnot stained(rag.0)\ninside(dishtowel.0, bottom_cabinet_no_top.80)\nnot soaked(dishtowel.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnot dusty(stove.88)\nnot stained(stove.88)\nnextto(rag.0, sink.82)\nnextto(dishtowel.0, sink.82)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet_no_top.80)\", \"holds_rh(soap.0) and holds_lh(rag.0)\", \"nextto(rag.0, sink.82)\", \"toggledon(sink.82)\", \"soaked(rag.0)\", \"holds_rh(rag.0)\", \"not dusty(stove.88) and not stained(stove.88)\", \"holds_rh(dishtowel.0)\", \"nextto(dishtowel.0, sink.82)\"]}"
    },
    "cleaning_table_after_clearing": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_table_after_clearing\n## Relevant objects in this scene\n{'name': 'breakfast_table.20', 'category': 'table_n_02'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'sink.53', 'category': 'sink_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n{'name': 'dishtowel.0', 'category': 'dishtowel_n_01'}\n{'name': 'bottom_cabinet.49', 'category': 'cabinet_n_01'}\n\n## Initial States\nstained(breakfast_table.20)\ninside(soap.0, bottom_cabinet.49)\ninside(dishtowel.0, bottom_cabinet.49)\nonfloor(agent_n_01.1, room_floor_dining_room.0)\n\n## Goal States\nnot stained(breakfast_table.20)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet.49)\", \"holds_rh(soap.0) and holds_lh(dishtowel.0)\", \"not stained(breakfast_table.20)\"]}"
    },
    "cleaning_the_hot_tub": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_the_hot_tub\n## Relevant objects in this scene\n{'name': 'pool.50', 'category': 'pool_n_01'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'scrub_brush.51', 'category': 'scrub_brush_n_01'}\n{'name': 'sink.38', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(pool.50, room_floor_garage.0)\nstained(pool.50)\nonfloor(scrub_brush.51, room_floor_garage.0)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nonfloor(pool.50, room_floor_garage.0)\nnot stained(pool.50)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(scrub_brush.51)\", \"not stained(pool.50)\"]}"
    },
    "cleaning_the_pool": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_the_pool\n## Relevant objects in this scene\n{'name': 'pool.50', 'category': 'pool_n_01'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'scrub_brush.51', 'category': 'scrub_brush_n_01'}\n{'name': 'shelf.16', 'category': 'shelf_n_01'}\n{'name': 'detergent.52', 'category': 'detergent_n_02'}\n{'name': 'sink.32', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(pool.50, room_floor_garage.0)\nstained(pool.50)\nonfloor(scrub_brush.51, room_floor_garage.0)\nonfloor(detergent.52, room_floor_garage.0)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nonfloor(pool.50, room_floor_garage.0)\nnot stained(pool.50)\nontop(scrub_brush.51, shelf.16)\nonfloor(detergent.52, room_floor_garage.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(detergent.52)\", \"not stained(pool.50)\", \"ontop(scrub_brush.51, shelf.16)\", \"onfloor(detergent.52, room_floor_garage.0)\"]}\n```"
    },
    "cleaning_toilet": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_toilet\n## Relevant objects in this scene\n{'name': 'toilet.45', 'category': 'toilet_n_02'}\n{'name': 'scrub_brush.70', 'category': 'scrub_brush_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'detergent.71', 'category': 'detergent_n_02'}\n{'name': 'sink.48', 'category': 'sink_n_01'}\n\n## Initial States\nstained(toilet.45)\nonfloor(scrub_brush.70, room_floor_bathroom.0)\nonfloor(detergent.71, room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnot stained(toilet.45)\nonfloor(scrub_brush.70, room_floor_bathroom.0)\nonfloor(detergent.71, room_floor_bathroom.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(detergent.71)\", \"not stained(toilet.45)\", \"onfloor(detergent.71, room_floor_bathroom.0)\"]}\n```"
    },
    "cleaning_up_after_a_meal": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_up_after_a_meal\n## Relevant objects in this scene\n{'name': 'bowl.143', 'category': 'bowl_n_01'}\n{'name': 'bowl.144', 'category': 'bowl_n_01'}\n{'name': 'breakfast_table.1', 'category': 'table_n_02'}\n{'name': 'paper_bag.145', 'category': 'sack_n_01'}\n{'name': 'straight_chair.2', 'category': 'chair_n_01'}\n{'name': 'straight_chair.3', 'category': 'chair_n_01'}\n{'name': 'plate.146', 'category': 'plate_n_04'}\n{'name': 'plate.147', 'category': 'plate_n_04'}\n{'name': 'plate.148', 'category': 'plate_n_04'}\n{'name': 'plate.149', 'category': 'plate_n_04'}\n{'name': 'cup.150', 'category': 'cup_n_01'}\n{'name': 'cup.151', 'category': 'cup_n_01'}\n{'name': 'hamburger.152', 'category': 'hamburger_n_01'}\n{'name': 'hamburger.153', 'category': 'hamburger_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'detergent.154', 'category': 'detergent_n_02'}\n{'name': 'dishwasher.83', 'category': 'dishwasher_n_01'}\n{'name': 'sink.82', 'category': 'sink_n_01'}\n\n## Initial States\nontop(bowl.143, breakfast_table.1)\nontop(bowl.144, breakfast_table.1)\nstained(bowl.143)\nstained(bowl.144)\nontop(paper_bag.145, breakfast_table.1)\nontop(plate.146, breakfast_table.1)\nontop(plate.147, breakfast_table.1)\nontop(plate.148, breakfast_table.1)\nontop(plate.149, breakfast_table.1)\nstained(plate.146)\nstained(plate.147)\nstained(plate.148)\nstained(plate.149)\nontop(cup.150, breakfast_table.1)\nontop(cup.151, breakfast_table.1)\nstained(cup.150)\nstained(cup.151)\nontop(hamburger.152, straight_chair.3)\nonfloor(hamburger.153, room_floor_dining_room.0)\nonfloor(detergent.154, room_floor_dining_room.0)\nstained(straight_chair.2)\nstained(straight_chair.3)\nstained(breakfast_table.1)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(bowl_n_01, (not stained(bowl_n_01)))\nforall(plate_n_04, (not stained(plate_n_04)))\nforall(cup_n_01, (not stained(cup_n_01)))\nforall(hamburger_n_01, inside(hamburger_n_01, paper_bag.145))\nonfloor(paper_bag.145, room_floor_dining_room.0)\nnot stained(room_floor_dining_room.0)\nnot stained(straight_chair.3)\nnot stained(room_floor_dining_room.0)\nnot stained(breakfast_table.1)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(detergent.154)\", \"not stained(straight_chair.3) and not stained(breakfast_table.1) and not stained(room_floor_dining_room.0)\", \"holds_rh(bowl.143)\", \"inside(bowl.143, dishwasher.83) and not holds_rh(bowl.143)\", \"holds_rh(bowl.144)\", \"inside(bowl.144, dishwasher.83) and not holds_rh(bowl.144)\", \"toggledon(dishwasher.83)\", \"not stained(bowl.143) and not stained(bowl.144)\", \"ontop(bowl.143, breakfast_table.1) and ontop(bowl.144, breakfast_table.1)\", \"holds_rh(plate.146)\", \"inside(plate.146, dishwasher.83) and not holds_rh(plate.146)\", \"holds_rh(plate.147)\", \"inside(plate.147, dishwasher.83) and not holds_rh(plate.147)\", \"holds_rh(plate.148)\", \"inside(plate.148, dishwasher.83) and not holds_rh(plate.148)\", \"holds_rh(plate.149)\", \"inside(plate.149, dishwasher.83) and not holds_rh(plate.149)\", \"toggledon(dishwasher.83)\", \"not stained(plate.146) and not stained(plate.147) and not stained(plate.148) and not stained(plate.149)\", \"ontop(plate.146, breakfast_table.1) and ontop(plate.147, breakfast_table.1) and ontop(plate.148, breakfast_table.1) and ontop(plate.149, breakfast_table.1)\", \"holds_rh(cup.150)\", \"inside(cup.150, dishwasher.83) and not holds_rh(cup.150)\", \"holds_rh(cup.151)\", \"inside(cup.151, dishwasher.83) and not holds_rh(cup.151)\", \"toggledon(dishwasher.83)\", \"not stained(cup.150) and not stained(cup.151)\", \"ontop(cup.150, breakfast_table.1) and ontop(cup.151, breakfast_table.1)\", \"holds_rh(hamburger.152)\", \"inside(hamburger.152, paper_bag.145) and not holds_rh(hamburger.152)\", \"holds_rh(hamburger.153)\", \"inside(hamburger.153, paper_bag.145) and not holds_rh(hamburger.153)\", \"onfloor(paper_bag.145, room_floor_dining_room.0)\"]}\n```"
    },
    "cleaning_up_refrigerator": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_up_refrigerator\n## Relevant objects in this scene\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'rag.1', 'category': 'rag_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'tray.0', 'category': 'tray_n_01'}\n{'name': 'tray.1', 'category': 'tray_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'bowl.0', 'category': 'bowl_n_01'}\n{'name': 'sink.82', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(rag.0, bottom_cabinet_no_top.80)\ninside(rag.1, bottom_cabinet_no_top.80)\nontop(soap.0, countertop.84)\ninside(tray.0, fridge.97)\ninside(tray.1, fridge.97)\ninside(bowl.0, fridge.97)\nnot soaked(rag.0)\nnot soaked(rag.1)\nstained(tray.0)\nstained(tray.1)\ndusty(bowl.0)\nstained(fridge.97)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(rag_n_01, nextto(rag_n_01, sink.82))\ninside(soap.0, sink.82)\nforall(tray_n_01, inside(tray_n_01, fridge.97))\nnot stained(tray.0)\nnot stained(tray.1)\nnextto(bowl.0, sink.82)\nnot dusty(bowl.0)\nnot stained(fridge.97)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"ontop(rag.0, countertop.84) and ontop(rag.1, countertop.84)\", \"ontop(tray.0, countertop.84) and ontop(tray.1, countertop.84) and ontop(bowl.0, countertop.84)\", \"holds_rh(rag.0)\", \"soaked(rag.0) and nextto(rag.0, sink.82)\", \"not stained(fridge.97)\", \"holds_rh(rag.1)\", \"soaked(rag.1) and nextto(rag.1, sink.82)\", \"not stained(tray.0) and not stained(tray.1)\", \"nextto(bowl.0, sink.82)\", \"holds_rh(soap.0)\", \"inside(soap.0, sink.82)\", \"not dusty(bowl.0)\"]}"
    },
    "cleaning_up_the_kitchen_only": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_up_the_kitchen_only\n## Relevant objects in this scene\n{'name': 'trash_can.78', 'category': 'bin_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'soap.79', 'category': 'soap_n_01'}\n{'name': 'top_cabinet.27', 'category': 'cabinet_n_01'}\n{'name': 'top_cabinet.24', 'category': 'cabinet_n_01'}\n{'name': 'fridge.20', 'category': 'electric_refrigerator_n_01'}\n{'name': 'rag.80', 'category': 'rag_n_01'}\n{'name': 'dustpan.81', 'category': 'dustpan_n_02'}\n{'name': 'broom.82', 'category': 'broom_n_01'}\n{'name': 'blender.83', 'category': 'blender_n_01'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'casserole.84', 'category': 'casserole_n_02'}\n{'name': 'plate.85', 'category': 'plate_n_04'}\n{'name': 'olive_oil.86', 'category': 'vegetable_oil_n_01'}\n{'name': 'apple.87', 'category': 'apple_n_01'}\n{'name': 'window.68', 'category': 'window_n_01'}\n{'name': 'countertop.31', 'category': 'countertop_n_01'}\n\n## Initial States\nonfloor(trash_can.78, room_floor_kitchen.0)\ninside(soap.79, top_cabinet.27)\ninside(rag.80, top_cabinet.27)\nnot soaked(rag.80)\ninside(dustpan.81, top_cabinet.27)\ndusty(dustpan.81)\nonfloor(broom.82, room_floor_kitchen.0)\ndusty(broom.82)\nonfloor(blender.83, room_floor_kitchen.0)\nstained(blender.83)\ninside(casserole.84, fridge.20)\ninside(plate.85, fridge.20)\nstained(plate.85)\ninside(olive_oil.86, fridge.20)\ninside(apple.87, fridge.20)\ndusty(room_floor_kitchen.0)\ndusty(top_cabinet.27)\ndusty(top_cabinet.24)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nontop(blender.83, countertop.31)\nnextto(soap.79, sink.37)\nexists(cabinet_n_01, (inside(olive_oil.86, cabinet_n_01) and (not inside(plate.85, cabinet_n_01))))\nexists(cabinet_n_01, (inside(plate.85, cabinet_n_01) and (not inside(olive_oil.86, cabinet_n_01))))\n(not dusty(top_cabinet.27)) and (not dusty(top_cabinet.24)) and (not dusty(room_floor_kitchen.0))\nnot stained(plate.85)\nnextto(rag.80, sink.37) or inside(rag.80, sink.37)\ninside(casserole.84, fridge.20) and inside(apple.87, fridge.20)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\n  \"output\": [\n    \"holds_rh(rag.80)\",\n    \"nextto(rag.80, sink.37) or inside(rag.80, sink.37)\",\n    \"holds_rh(dustpan.81)\",\n    \"inside(dustpan.81, sink.37) and toggledon(sink.37)\",\n    \"not dusty(dustpan.81)\",\n    \"holds_rh(broom.82)\",\n    \"inside(broom.82, sink.37) and toggledon(sink.37)\",\n    \"not dusty(broom.82)\",\n    \"not dusty(room_floor_kitchen.0)\",\n    \"not dusty(top_cabinet.27) and not dusty(top_cabinet.24)\",\n    \"holds_rh(plate.85)\",\n    \"inside(plate.85, sink.37) and toggledon(sink.37)\",\n    \"not stained(plate.85)\",\n    \"ontop(blender.83, countertop.31)\",\n    \"holds_rh(soap.79)\",\n    \"nextto(soap.79, sink.37)\",\n    \"inside(olive_oil.86, top_cabinet.24) and not inside(plate.85, top_cabinet.24)\",\n    \"inside(plate.85, top_cabinet.27) and not inside(olive_oil.86, top_cabinet.27)\",\n    \"inside(casserole.84, fridge.20) and inside(apple.87, fridge.20)\"\n  ]\n}\n```"
    },
    "cleaning_windows": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: cleaning_windows\n## Relevant objects in this scene\n{'name': 'dishtowel.0', 'category': 'towel_n_01'}\n{'name': 'dishtowel.1', 'category': 'towel_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'rag.1', 'category': 'rag_n_01'}\n{'name': 'toothpaste.0', 'category': 'cleansing_agent_n_01'}\n{'name': 'window.133', 'category': 'window_n_01'}\n{'name': 'window.119', 'category': 'window_n_01'}\n{'name': 'sink.82', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'coffee_table.33', 'category': 'table_n_02'}\n\n## Initial States\ninside(dishtowel.0, bottom_cabinet_no_top.80)\ninside(dishtowel.1, bottom_cabinet_no_top.80)\ninside(rag.0, bottom_cabinet_no_top.80)\ninside(rag.1, bottom_cabinet_no_top.80)\nnot soaked(rag.0)\nnot soaked(rag.1)\ninside(toothpaste.0, bottom_cabinet_no_top.80)\ndusty(window.133)\ndusty(window.119)\nnot dusty(sink.82)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nsoaked(rag.0) and soaked(rag.1)\n(not dusty(window.133)) and (not dusty(window.119))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet_no_top.80)\", \"holds_rh(rag.0)\", \"inside(rag.0, sink.82)\", \"toggledon(sink.82)\", \"soaked(rag.0)\", \"holds_lh(rag.1)\", \"inside(rag.1, sink.82)\", \"soaked(rag.1)\", \"holds_rh(rag.0) and holds_lh(rag.1)\", \"not dusty(window.133) and not dusty(window.119)\"]}"
    },
    "clearing_the_table_after_dinner": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: clearing_the_table_after_dinner\n## Relevant objects in this scene\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n{'name': 'straight_chair.3', 'category': 'chair_n_01'}\n{'name': 'straight_chair.4', 'category': 'chair_n_01'}\n{'name': 'breakfast_table.2', 'category': 'table_n_02'}\n{'name': 'cup.0', 'category': 'cup_n_01'}\n{'name': 'cup.1', 'category': 'cup_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'bucket.1', 'category': 'bucket_n_01'}\n{'name': 'bowl.0', 'category': 'bowl_n_01'}\n{'name': 'bowl.1', 'category': 'bowl_n_01'}\n{'name': 'bowl.2', 'category': 'bowl_n_01'}\n{'name': 'bowl.3', 'category': 'bowl_n_01'}\n{'name': 'catsup.0', 'category': 'catsup_n_01'}\n{'name': 'pop.0', 'category': 'beverage_n_01'}\n{'name': 'pop.1', 'category': 'beverage_n_01'}\n\n## Initial States\nontop(cup.0, breakfast_table.2)\nontop(cup.1, breakfast_table.2)\nonfloor(bucket.0, room_floor_dining_room.0)\nontop(bowl.0, breakfast_table.2)\nontop(bowl.1, breakfast_table.2)\nontop(bowl.2, breakfast_table.2)\nontop(bowl.3, breakfast_table.2)\nontop(catsup.0, breakfast_table.2)\nontop(pop.0, breakfast_table.2)\nonfloor(pop.1, room_floor_dining_room.0)\nonfloor(bucket.1, room_floor_dining_room.0)\nonfloor(agent_n_01.1, room_floor_dining_room.0)\n\n## Goal States\nforall(cup_n_01, exists(bucket_n_01, inside(cup_n_01, bucket_n_01)))\nforall(bowl_n_01, exists(bucket_n_01, inside(bowl_n_01, bucket_n_01)))\nexists(bucket_n_01, inside(catsup.0, bucket_n_01))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\n  \"output\": [\n    \"holds_rh(cup.0)\",\n    \"inside(cup.0, bucket.0)\",\n    \"holds_rh(cup.1)\",\n    \"inside(cup.1, bucket.0)\",\n    \"holds_rh(bowl.0)\",\n    \"inside(bowl.0, bucket.0)\",\n    \"holds_rh(bowl.1)\",\n    \"inside(bowl.1, bucket.0)\",\n    \"holds_rh(bowl.2)\",\n    \"inside(bowl.2, bucket.0)\",\n    \"holds_rh(bowl.3)\",\n    \"inside(bowl.3, bucket.0)\",\n    \"holds_rh(catsup.0)\",\n    \"inside(catsup.0, bucket.0)\"\n  ]\n}\n```"
    },
    "collecting_aluminum_cans": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: collecting_aluminum_cans\n## Relevant objects in this scene\n{'name': 'pop.112', 'category': 'pop_n_02'}\n{'name': 'pop.113', 'category': 'pop_n_02'}\n{'name': 'pop.114', 'category': 'pop_n_02'}\n{'name': 'pop.115', 'category': 'pop_n_02'}\n{'name': 'pop.116', 'category': 'pop_n_02'}\n{'name': 'pop.117', 'category': 'pop_n_02'}\n{'name': 'bed.33', 'category': 'bed_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'bucket.118', 'category': 'bucket_n_01'}\n\n## Initial States\nontop(pop.112, bed.33)\nontop(pop.113, bed.33)\nontop(pop.114, bed.33)\nonfloor(pop.115, room_floor_bedroom.0)\nonfloor(pop.116, room_floor_bedroom.0)\nonfloor(pop.117, room_floor_bedroom.0)\nontop(bucket.118, bed.33)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(pop_n_02, inside(pop_n_02, bucket.118))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(bucket.118)\", \"ontop(bucket.118, room_floor_bedroom.0)\", \"holds_rh(pop.112)\", \"inside(pop.112, bucket.118)\", \"holds_rh(pop.113)\", \"inside(pop.113, bucket.118)\", \"holds_rh(pop.114)\", \"inside(pop.114, bucket.118)\", \"holds_rh(pop.115)\", \"inside(pop.115, bucket.118)\", \"holds_rh(pop.116)\", \"inside(pop.116, bucket.118)\", \"holds_rh(pop.117)\", \"inside(pop.117, bucket.118)\"]}"
    },
    "collect_misplaced_items": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: collect_misplaced_items\n## Relevant objects in this scene\n{'name': 'gym_shoe.0', 'category': 'gym_shoe_n_01'}\n{'name': 'necklace.0', 'category': 'necklace_n_01'}\n{'name': 'notebook.0', 'category': 'notebook_n_01'}\n{'name': 'sock.0', 'category': 'sock_n_01'}\n{'name': 'sock.1', 'category': 'sock_n_01'}\n{'name': 'coffee_table.33', 'category': 'table_n_02'}\n{'name': 'breakfast_table.1', 'category': 'table_n_02'}\n{'name': 'bottom_cabinet.79', 'category': 'cabinet_n_01'}\n{'name': 'sofa.39', 'category': 'sofa_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n\n## Initial States\nunder(gym_shoe.0, coffee_table.33)\nonfloor(gym_shoe.0, room_floor_dining_room.0)\ninside(necklace.0, bottom_cabinet.79)\nunder(notebook.0, breakfast_table.1)\nontop(sock.0, sofa.39)\nonfloor(sock.1, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nontop(gym_shoe.0, breakfast_table.1)\nontop(necklace.0, breakfast_table.1)\nontop(notebook.0, breakfast_table.1)\nforall(sock_n_01, ontop(sock_n_01, breakfast_table.1))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(gym_shoe.0)\", \"ontop(gym_shoe.0, breakfast_table.1)\", \"holds_rh(necklace.0)\", \"ontop(necklace.0, breakfast_table.1)\", \"holds_rh(notebook.0)\", \"ontop(notebook.0, breakfast_table.1)\", \"holds_rh(sock.0)\", \"ontop(sock.0, breakfast_table.1)\", \"holds_rh(sock.1)\", \"ontop(sock.1, breakfast_table.1)\"]}\n```"
    },
    "defrosting_freezer": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: defrosting_freezer\n## Relevant objects in this scene\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'fridge.57', 'category': 'electric_refrigerator_n_01'}\n{'name': 'sink.64', 'category': 'sink_n_01'}\n{'name': 'countertop.56', 'category': 'countertop_n_01'}\n{'name': 'dustpan.0', 'category': 'receptacle_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'scraper.0', 'category': 'scraper_n_01'}\n{'name': 'paper_towel.0', 'category': 'towel_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'pomelo.0', 'category': 'food_n_02'}\n{'name': 'pear.0', 'category': 'food_n_02'}\n{'name': 'pea.0', 'category': 'food_n_02'}\n\n## Initial States\nnot stained(sink.64)\nonfloor(dustpan.0, room_floor_kitchen.0)\nonfloor(bucket.0, room_floor_kitchen.0)\nontop(scraper.0, countertop.56)\nontop(paper_towel.0, countertop.56)\nnot stained(paper_towel.0)\nontop(rag.0, countertop.56)\nnot soaked(rag.0)\ninside(pomelo.0, fridge.57)\ninside(pear.0, fridge.57)\ninside(pea.0, fridge.57)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnextto(dustpan.0, fridge.57)\nnextto(bucket.0, countertop.56)\nontop(scraper.0, fridge.57)\nontop(paper_towel.0, countertop.56)\ninside(rag.0, sink.64)\nsoaked(rag.0)\nforall(food_n_02, inside(food_n_02, bucket.0))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(dustpan.0)\", \"nextto(dustpan.0, fridge.57)\", \"holds_rh(bucket.0)\", \"nextto(bucket.0, countertop.56)\", \"holds_rh(scraper.0)\", \"ontop(scraper.0, fridge.57)\", \"holds_rh(rag.0)\", \"inside(rag.0, sink.64)\", \"toggledon(sink.64)\", \"soaked(rag.0)\", \"holds_rh(pomelo.0)\", \"inside(pomelo.0, bucket.0)\", \"holds_rh(pear.0)\", \"inside(pear.0, bucket.0)\", \"holds_rh(pea.0)\", \"inside(pea.0, bucket.0)\"]}"
    },
    "filling_an_Easter_basket": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: filling_an_Easter_basket\n## Relevant objects in this scene\n{'name': 'basket.0', 'category': 'basket_n_01'}\n{'name': 'basket.1', 'category': 'basket_n_01'}\n{'name': 'countertop.18', 'category': 'countertop_n_01'}\n{'name': 'ball.0', 'category': 'ball_n_01'}\n{'name': 'bracelet.0', 'category': 'jewelry_n_01'}\n{'name': 'notebook.0', 'category': 'book_n_02'}\n{'name': 'notebook.1', 'category': 'book_n_02'}\n{'name': 'bottom_cabinet_no_top.15', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet_no_top.16', 'category': 'cabinet_n_01'}\n{'name': 'bow.0', 'category': 'bow_n_08'}\n{'name': 'bow.1', 'category': 'bow_n_08'}\n{'name': 'egg.0', 'category': 'egg_n_02'}\n{'name': 'egg.1', 'category': 'egg_n_02'}\n{'name': 'fridge.27', 'category': 'electric_refrigerator_n_01'}\n{'name': 'lollipop.0', 'category': 'candy_n_01'}\n{'name': 'lollipop.1', 'category': 'candy_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(basket.0, countertop.18)\nontop(basket.1, countertop.18)\nontop(ball.0, countertop.18)\nontop(bracelet.0, countertop.18)\ninside(notebook.0, bottom_cabinet_no_top.15)\ninside(notebook.1, bottom_cabinet_no_top.15)\ninside(bow.0, bottom_cabinet_no_top.16)\ninside(bow.1, bottom_cabinet_no_top.16)\ninside(egg.0, fridge.27)\ncooked(egg.0)\ninside(egg.1, fridge.27)\ncooked(egg.1)\nontop(lollipop.0, fridge.27)\nontop(lollipop.1, fridge.27)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(basket_n_01, ontop(basket_n_01, countertop.18))\nforpairs(basket_n_01, egg_n_02, inside(egg_n_02, basket_n_01))\nforpairs(basket_n_01, candy_n_01, inside(candy_n_01, basket_n_01))\nexists(basket_n_01, (inside(bracelet.0, basket_n_01) and inside(ball.0, basket_n_01)))\nforpairs(bow_n_08, basket_n_01, (ontop(bow_n_08, basket_n_01) or inside(bow_n_08, basket_n_01)))\nforpairs(book_n_02, basket_n_01, nextto(book_n_02, basket_n_01))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(egg.0)\", \"inside(egg.0, basket.0)\", \"holds_rh(egg.1)\", \"inside(egg.1, basket.1)\", \"holds_rh(lollipop.0)\", \"inside(lollipop.0, basket.0)\", \"holds_rh(lollipop.1)\", \"inside(lollipop.1, basket.1)\", \"holds_rh(bracelet.0)\", \"inside(bracelet.0, basket.0) and inside(ball.0, basket.0)\", \"holds_rh(ball.0)\", \"holds_rh(notebook.0)\", \"nextto(notebook.0, basket.0)\", \"holds_rh(notebook.1)\", \"nextto(notebook.1, basket.1)\", \"holds_rh(bow.0)\", \"ontop(bow.0, basket.0) or inside(bow.0, basket.0)\", \"holds_rh(bow.1)\", \"ontop(bow.1, basket.1) or inside(bow.1, basket.1)\"]}"
    },
    "filling_a_Christmas_stocking": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: filling_a_Christmas_stocking\n## Relevant objects in this scene\n{'name': 'ice_cube.0', 'category': 'cube_n_05'}\n{'name': 'ice_cube.1', 'category': 'cube_n_05'}\n{'name': 'ice_cube.2', 'category': 'cube_n_05'}\n{'name': 'ice_cube.3', 'category': 'cube_n_05'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'lollipop.0', 'category': 'candy_n_01'}\n{'name': 'candy_cane.0', 'category': 'candy_n_01'}\n{'name': 'lollipop.1', 'category': 'candy_n_01'}\n{'name': 'lollipop.2', 'category': 'candy_n_01'}\n{'name': 'bottom_cabinet.41', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.46', 'category': 'cabinet_n_01'}\n{'name': 'pen.0', 'category': 'pen_n_01'}\n{'name': 'pen.1', 'category': 'pen_n_01'}\n{'name': 'pen.2', 'category': 'pen_n_01'}\n{'name': 'pen.3', 'category': 'pen_n_01'}\n{'name': 'stocking.0', 'category': 'stocking_n_01'}\n{'name': 'stocking.1', 'category': 'stocking_n_01'}\n{'name': 'stocking.2', 'category': 'stocking_n_01'}\n{'name': 'stocking.3', 'category': 'stocking_n_01'}\n\n## Initial States\nonfloor(ice_cube.0, room_floor_living_room.0)\nonfloor(ice_cube.1, room_floor_living_room.0)\nonfloor(ice_cube.2, room_floor_living_room.0)\nonfloor(ice_cube.3, room_floor_living_room.0)\ninside(lollipop.0, bottom_cabinet.41)\ninside(candy_cane.0, bottom_cabinet.41)\ninside(lollipop.1, bottom_cabinet.41)\ninside(lollipop.2, bottom_cabinet.41)\ninside(pen.0, bottom_cabinet.41)\ninside(pen.1, bottom_cabinet.41)\ninside(pen.2, bottom_cabinet.41)\ninside(pen.3, bottom_cabinet.41)\nonfloor(stocking.0, room_floor_living_room.0)\nonfloor(stocking.1, room_floor_living_room.0)\nonfloor(stocking.2, room_floor_living_room.0)\nonfloor(stocking.3, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforpairs(stocking_n_01, cube_n_05, inside(cube_n_05, stocking_n_01))\nforpairs(stocking_n_01, candy_n_01, inside(candy_n_01, stocking_n_01))\nforpairs(stocking_n_01, pen_n_01, inside(pen_n_01, stocking_n_01))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"open(bottom_cabinet.41)\", \"holds_rh(lollipop.0)\", \"inside(lollipop.0, stocking.0)\", \"holds_rh(candy_cane.0)\", \"inside(candy_cane.0, stocking.1)\", \"holds_rh(lollipop.1)\", \"inside(lollipop.1, stocking.2)\", \"holds_rh(lollipop.2)\", \"inside(lollipop.2, stocking.3)\", \"holds_rh(pen.0)\", \"inside(pen.0, stocking.0)\", \"holds_rh(pen.1)\", \"inside(pen.1, stocking.1)\", \"holds_rh(pen.2)\", \"inside(pen.2, stocking.2)\", \"holds_rh(pen.3)\", \"inside(pen.3, stocking.3)\", \"holds_rh(ice_cube.0)\", \"inside(ice_cube.0, stocking.0)\", \"holds_rh(ice_cube.1)\", \"inside(ice_cube.1, stocking.1)\", \"holds_rh(ice_cube.2)\", \"inside(ice_cube.2, stocking.2)\", \"holds_rh(ice_cube.3)\", \"inside(ice_cube.3, stocking.3)\"]}\n```"
    },
    "installing_alarms": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: installing_alarms\n## Relevant objects in this scene\n{'name': 'alarm.0', 'category': 'alarm_n_02'}\n{'name': 'alarm.1', 'category': 'alarm_n_02'}\n{'name': 'breakfast_table.20', 'category': 'table_n_02'}\n{'name': 'coffee_table.27', 'category': 'table_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(alarm.0, coffee_table.27)\nontop(alarm.1, coffee_table.27)\nnot toggled.on(alarm.0)\nnot toggled.on(alarm.1)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforpairs(alarm_n_02, table_n_02, ontop(alarm_n_02, table_n_02))\nforall(alarm_n_02, toggled.on(alarm_n_02))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"ontop(alarm.0, breakfast_table.20) and ontop(alarm.1, coffee_table.27)\", \"toggled.on(alarm.0) and toggled.on(alarm.1)\"]}"
    },
    "installing_a_fax_machine": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: installing_a_fax_machine\n## Relevant objects in this scene\n{'name': 'facsimile.0', 'category': 'facsimile_n_02'}\n{'name': 'room_floor_home_office.0', 'category': 'floor_n_01'}\n{'name': 'breakfast_table.37', 'category': 'table_n_02'}\n\n## Initial States\nonfloor(facsimile.0, room_floor_home_office.0)\nnot toggled.on(facsimile.0)\nonfloor(agent_n_01.1, room_floor_home_office.0)\n\n## Goal States\nontop(facsimile.0, breakfast_table.37)\ntoggled.on(facsimile.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(facsimile.0)\", \"ontop(facsimile.0, breakfast_table.37)\", \"toggled.on(facsimile.0)\"]}"
    },
    "installing_a_modem": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: installing_a_modem\n## Relevant objects in this scene\n{'name': 'modem.0', 'category': 'modem_n_01'}\n{'name': 'breakfast_table.37', 'category': 'table_n_02'}\n{'name': 'room_floor_home_office.0', 'category': 'floor_n_01'}\n\n## Initial States\nnot toggled.on(modem.0)\nontop(modem.0, breakfast_table.37)\nonfloor(agent_n_01.1, room_floor_home_office.0)\n\n## Goal States\ntoggled.on(modem.0)\nunder(modem.0, breakfast_table.37)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(modem.0)\", \"under(modem.0, breakfast_table.37)\", \"not holds_rh(modem.0)\", \"toggled.on(modem.0)\"]}"
    },
    "installing_a_printer": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: installing_a_printer\n## Relevant objects in this scene\n{'name': 'printer.0', 'category': 'printer_n_03'}\n{'name': 'room_floor_home_office.0', 'category': 'floor_n_01'}\n{'name': 'breakfast_table.3', 'category': 'table_n_02'}\n\n## Initial States\nonfloor(printer.0, room_floor_home_office.0)\nnot toggled.on(printer.0)\nonfloor(agent_n_01.1, room_floor_home_office.0)\n\n## Goal States\nontop(printer.0, breakfast_table.3)\ntoggled.on(printer.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(printer.0)\", \"ontop(printer.0, breakfast_table.3)\", \"toggled.on(printer.0)\"]}"
    },
    "installing_a_scanner": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: installing_a_scanner\n## Relevant objects in this scene\n{'name': 'scanner.0', 'category': 'scanner_n_02'}\n{'name': 'breakfast_table.3', 'category': 'table_n_02'}\n{'name': 'room_floor_home_office.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(scanner.0, breakfast_table.3)\nnot toggled.on(scanner.0)\nonfloor(agent_n_01.1, room_floor_home_office.0)\n\n## Goal States\ntoggled.on(scanner.0)\nunder(scanner.0, breakfast_table.3)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(scanner.0)\", \"under(scanner.0, breakfast_table.3)\", \"toggled.on(scanner.0)\"]}"
    },
    "laying_tile_floors": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: laying_tile_floors\n## Relevant objects in this scene\n{'name': 'tile.0', 'category': 'tile_n_01'}\n{'name': 'tile.1', 'category': 'tile_n_01'}\n{'name': 'tile.2', 'category': 'tile_n_01'}\n{'name': 'tile.3', 'category': 'tile_n_01'}\n{'name': 'room_floor_corridor.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n\n## Initial States\nonfloor(tile.0, room_floor_corridor.0)\nonfloor(tile.1, room_floor_corridor.0)\nonfloor(tile.2, room_floor_corridor.0)\nonfloor(tile.3, room_floor_corridor.0)\nonfloor(agent_n_01.1, room_floor_corridor.0)\n\n## Goal States\nforall(tile_n_01, onfloor(tile_n_01, room_floor_bathroom.0))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(tile.0)\", \"onfloor(tile.0, room_floor_bathroom.0)\", \"holds_rh(tile.1)\", \"onfloor(tile.1, room_floor_bathroom.0)\", \"holds_rh(tile.2)\", \"onfloor(tile.2, room_floor_bathroom.0)\", \"holds_rh(tile.3)\", \"onfloor(tile.3, room_floor_bathroom.0)\"]}"
    },
    "laying_wood_floors": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: laying_wood_floors\n## Relevant objects in this scene\n{'name': 'plywood.78', 'category': 'plywood_n_01'}\n{'name': 'plywood.79', 'category': 'plywood_n_01'}\n{'name': 'plywood.80', 'category': 'plywood_n_01'}\n{'name': 'plywood.81', 'category': 'plywood_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'hammer.82', 'category': 'hammer_n_02'}\n{'name': 'saw.83', 'category': 'saw_n_02'}\n\n## Initial States\nonfloor(plywood.78, room_floor_kitchen.0)\nonfloor(plywood.79, room_floor_kitchen.0)\nonfloor(plywood.80, room_floor_kitchen.0)\nonfloor(plywood.81, room_floor_kitchen.0)\nonfloor(hammer.82, room_floor_kitchen.0)\nonfloor(saw.83, room_floor_kitchen.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(plywood_n_01, onfloor(plywood_n_01, room_floor_living_room.0))\nforall(plywood_n_01, (nextto(plywood_n_01, plywood.78) or nextto(plywood_n_01, plywood.79) or nextto(plywood_n_01, plywood.80) or nextto(plywood_n_01, plywood.81)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(plywood.78)\", \"onfloor(plywood.78, room_floor_living_room.0)\", \"nextto(plywood.78, plywood.79) or nextto(plywood.78, plywood.80) or nextto(plywood.78, plywood.81)\", \"holds_rh(plywood.79)\", \"onfloor(plywood.79, room_floor_living_room.0)\", \"nextto(plywood.79, plywood.78) or nextto(plywood.79, plywood.80) or nextto(plywood.79, plywood.81)\", \"holds_rh(plywood.80)\", \"onfloor(plywood.80, room_floor_living_room.0)\", \"nextto(plywood.80, plywood.78) or nextto(plywood.80, plywood.79) or nextto(plywood.80, plywood.81)\", \"holds_rh(plywood.81)\", \"onfloor(plywood.81, room_floor_living_room.0)\", \"nextto(plywood.81, plywood.78) or nextto(plywood.81, plywood.79) or nextto(plywood.81, plywood.80)\"]}\n```"
    },
    "loading_the_dishwasher": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: loading_the_dishwasher\n## Relevant objects in this scene\n{'name': 'plate.59', 'category': 'plate_n_04'}\n{'name': 'plate.60', 'category': 'plate_n_04'}\n{'name': 'plate.61', 'category': 'plate_n_04'}\n{'name': 'countertop.18', 'category': 'countertop_n_01'}\n{'name': 'mug.62', 'category': 'mug_n_04'}\n{'name': 'bowl.63', 'category': 'bowl_n_01'}\n{'name': 'bowl.64', 'category': 'bowl_n_01'}\n{'name': 'dishwasher.20', 'category': 'dishwasher_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(plate.59, countertop.18)\nstained(plate.59)\nontop(plate.60, countertop.18)\nstained(plate.60)\nontop(plate.61, countertop.18)\nstained(plate.61)\nontop(mug.62, countertop.18)\nstained(mug.62)\nontop(bowl.63, countertop.18)\nstained(bowl.63)\nontop(bowl.64, countertop.18)\nstained(bowl.64)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(plate_n_04, inside(plate_n_04, dishwasher.20))\nforall(bowl_n_01, inside(bowl_n_01, dishwasher.20))\ninside(mug.62, dishwasher.20)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n\"output\": [\n    \"open(dishwasher.20)\",\n    \"holds_rh(plate.59)\",\n    \"inside(plate.59, dishwasher.20)\",\n    \"holds_rh(plate.60)\",\n    \"inside(plate.60, dishwasher.20)\",\n    \"holds_rh(plate.61)\",\n    \"inside(plate.61, dishwasher.20)\",\n    \"holds_rh(mug.62)\",\n    \"inside(mug.62, dishwasher.20)\",\n    \"holds_rh(bowl.63)\",\n    \"inside(bowl.63, dishwasher.20)\",\n    \"holds_rh(bowl.64)\",\n    \"inside(bowl.64, dishwasher.20)\",\n    \"not open(dishwasher.20)\"\n]\n}"
    },
    "locking_every_door": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: locking_every_door\n## Relevant objects in this scene\n{'name': 'door.85', 'category': 'door_n_01'}\n{'name': 'door.89', 'category': 'door_n_01'}\n{'name': 'bed.7', 'category': 'bed_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n\n## Initial States\nopen(door.85)\nopen(door.89)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nnot open(door.85)\nnot open(door.89)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n  \"output\": [\n    \"not open(door.85)\",\n    \"not open(door.89)\"\n  ]\n}"
    },
    "locking_every_window": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: locking_every_window\n## Relevant objects in this scene\n{'name': 'window.79', 'category': 'window_n_01'}\n{'name': 'window.76', 'category': 'window_n_01'}\n{'name': 'window.82', 'category': 'window_n_01'}\n{'name': 'window.81', 'category': 'window_n_01'}\n{'name': 'bed.7', 'category': 'bed_n_01'}\n{'name': 'sofa.25', 'category': 'sofa_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n\n## Initial States\nopen(window.79)\nopen(window.76)\nopen(window.82)\nopen(window.81)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nnot open(window.79)\nnot open(window.76)\nnot open(window.82)\nnot open(window.81)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"not open(window.79)\", \"not open(window.76)\", \"not open(window.82)\", \"not open(window.81)\"]}"
    },
    "making_tea": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: making_tea\n## Relevant objects in this scene\n{'name': 'teapot.0', 'category': 'teapot_n_01'}\n{'name': 'tea_bag.0', 'category': 'tea_bag_n_01'}\n{'name': 'lemon.0', 'category': 'lemon_n_01'}\n{'name': 'carving_knife.0', 'category': 'knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'stove.88', 'category': 'stove_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(teapot.0, bottom_cabinet_no_top.80)\ninside(tea_bag.0, bottom_cabinet_no_top.80)\ninside(lemon.0, fridge.97)\ninside(carving_knife.0, bottom_cabinet_no_top.80)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nsliced(lemon.0)\nontop(teapot.0, stove.88)\ninside(tea_bag.0, teapot.0)\nsoaked(tea_bag.0)\ntoggled.on(stove.88)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet_no_top.80)\", \"ontop(teapot.0, stove.88) and ontop(tea_bag.0, countertop.84) and ontop(carving_knife.0, countertop.84)\", \"open(fridge.97)\", \"ontop(lemon.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(lemon.0)\", \"inside(tea_bag.0, teapot.0)\", \"toggled.on(stove.88)\", \"soaked(tea_bag.0)\"]}"
    },
    "mopping_floors": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: mopping_floors\n## Relevant objects in this scene\n{'name': 'broom.0', 'category': 'broom_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_corridor.0', 'category': 'floor_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'dishtowel.0', 'category': 'piece_of_cloth_n_01'}\n{'name': 'sink.28', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(broom.0, room_floor_corridor.0)\nonfloor(soap.0, room_floor_bathroom.0)\nonfloor(bucket.0, room_floor_bathroom.0)\nonfloor(dishtowel.0, room_floor_bathroom.0)\nstained(room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnot stained(room_floor_bathroom.0)\nnextto(bucket.0, sink.28)\ninside(soap.0, bucket.0)\nnextto(broom.0, sink.28)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(broom.0)\", \"nextto(broom.0, sink.28)\", \"holds_rh(bucket.0)\", \"nextto(bucket.0, sink.28)\", \"holds_rh(soap.0)\", \"inside(soap.0, bucket.0)\", \"holds_rh(dishtowel.0)\", \"soaked(dishtowel.0)\", \"holds_rh(dishtowel.0) and not stained(room_floor_bathroom.0)\"]}\n```"
    },
    "moving_boxes_to_storage": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: moving_boxes_to_storage\n## Relevant objects in this scene\n{'name': 'carton.70', 'category': 'carton_n_02'}\n{'name': 'carton.71', 'category': 'carton_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_storage_room.0', 'category': 'floor_n_01'}\n{'name': 'shelf.7', 'category': 'shelf_n_01'}\n\n## Initial States\nonfloor(carton.70, room_floor_living_room.0)\nonfloor(carton.71, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_storage_room.0)\n\n## Goal States\nonfloor(carton.70, room_floor_storage_room.0)\nontop(carton.71, carton.70)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(carton.70)\", \"onfloor(carton.70, room_floor_storage_room.0)\", \"holds_rh(carton.71)\", \"ontop(carton.71, carton.70)\"]}"
    },
    "opening_packages": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: opening_packages\n## Relevant objects in this scene\n{'name': 'package.0', 'category': 'package_n_02'}\n{'name': 'package.1', 'category': 'package_n_02'}\n{'name': 'room_floor_bedroom.1', 'category': 'floor_n_01'}\n\n## Initial States\nonfloor(package.0, room_floor_bedroom.1)\nonfloor(package.1, room_floor_bedroom.1)\nnot open(package.0)\nnot open(package.1)\nonfloor(agent_n_01.1, room_floor_bedroom.1)\n\n## Goal States\nforall(package_n_02, open(package_n_02))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(package.0)\", \"open(package.0)\", \"not holds_rh(package.0)\", \"holds_rh(package.1)\", \"open(package.1)\"]}"
    },
    "opening_presents": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: opening_presents\n## Relevant objects in this scene\n{'name': 'package.0', 'category': 'package_n_02'}\n{'name': 'package.1', 'category': 'package_n_02'}\n{'name': 'room_floor_bedroom.1', 'category': 'floor_n_01'}\n{'name': 'bed.10', 'category': 'bed_n_01'}\n\n## Initial States\nonfloor(package.0, room_floor_bedroom.1)\nonfloor(package.1, room_floor_bedroom.1)\nnot open(package.0)\nnot open(package.1)\nonfloor(agent_n_01.1, room_floor_bedroom.1)\n\n## Goal States\nforall(package_n_02, open(package_n_02))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(package.0)\", \"open(package.0)\", \"holds_rh(package.1)\", \"open(package.1)\"]}"
    },
    "organizing_boxes_in_garage": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: organizing_boxes_in_garage\n## Relevant objects in this scene\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'carton.1', 'category': 'carton_n_02'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'ball.0', 'category': 'ball_n_01'}\n{'name': 'ball.1', 'category': 'ball_n_01'}\n{'name': 'plate.0', 'category': 'plate_n_04'}\n{'name': 'plate.1', 'category': 'plate_n_04'}\n{'name': 'plate.2', 'category': 'plate_n_04'}\n{'name': 'bottom_cabinet.15', 'category': 'cabinet_n_01'}\n{'name': 'saucepan.0', 'category': 'saucepan_n_01'}\n{'name': 'shelf.16', 'category': 'shelf_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_garage.0)\nonfloor(carton.1, room_floor_garage.0)\nonfloor(ball.0, room_floor_garage.0)\nonfloor(ball.1, room_floor_garage.0)\ninside(plate.0, shelf.16)\ninside(plate.1, shelf.16)\ninside(plate.2, shelf.16)\ninside(saucepan.0, shelf.16)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nexists(carton_n_02, (forall(ball_n_01, inside(ball_n_01, carton_n_02)) and forall(plate_n_04, inside(plate_n_04, carton_n_02)) and inside(saucepan.0, carton_n_02)))\nforall(carton_n_02, onfloor(carton_n_02, room_floor_garage.0))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"open(carton.0) and open(carton.1)\", \"holds_rh(ball.0)\", \"inside(ball.0, carton.0)\", \"holds_rh(ball.1)\", \"inside(ball.1, carton.0)\", \"holds_rh(plate.0)\", \"inside(plate.0, carton.0)\", \"holds_rh(plate.1)\", \"inside(plate.1, carton.0)\", \"holds_rh(plate.2)\", \"inside(plate.2, carton.0)\", \"holds_rh(saucepan.0)\", \"inside(saucepan.0, carton.0)\", \"not open(carton.0) and not open(carton.1)\"]}\n```"
    },
    "organizing_file_cabinet": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: organizing_file_cabinet\n## Relevant objects in this scene\n{'name': 'room_floor_home_office.0', 'category': 'floor_n_01'}\n{'name': 'highlighter.0', 'category': 'marker_n_03'}\n{'name': 'swivel_chair.5', 'category': 'chair_n_01'}\n{'name': 'document.0', 'category': 'document_n_01'}\n{'name': 'document.1', 'category': 'document_n_01'}\n{'name': 'document.2', 'category': 'document_n_01'}\n{'name': 'document.3', 'category': 'document_n_01'}\n{'name': 'breakfast_table.3', 'category': 'table_n_02'}\n{'name': 'bottom_cabinet_no_top.21', 'category': 'cabinet_n_01'}\n{'name': 'folder.0', 'category': 'folder_n_02'}\n{'name': 'folder.1', 'category': 'folder_n_02'}\n\n## Initial States\nontop(highlighter.0, swivel_chair.5)\nontop(document.0, breakfast_table.3)\ninside(document.1, bottom_cabinet_no_top.21)\nontop(document.2, breakfast_table.3)\ninside(document.3, bottom_cabinet_no_top.21)\nontop(folder.0, breakfast_table.3)\nonfloor(folder.1, room_floor_home_office.0)\nonfloor(agent_n_01.1, room_floor_home_office.0)\n\n## Goal States\nontop(highlighter.0, breakfast_table.3)\nforall(document_n_01, inside(document_n_01, bottom_cabinet_no_top.21))\nforall(folder_n_02, inside(folder_n_02, bottom_cabinet_no_top.21))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(highlighter.0)\", \"ontop(highlighter.0, breakfast_table.3)\", \"holds_rh(document.0)\", \"inside(document.0, bottom_cabinet_no_top.21)\", \"holds_rh(document.2)\", \"inside(document.2, bottom_cabinet_no_top.21)\", \"holds_rh(folder.0)\", \"inside(folder.0, bottom_cabinet_no_top.21)\", \"holds_rh(folder.1)\", \"inside(folder.1, bottom_cabinet_no_top.21)\"]}\n```"
    },
    "organizing_school_stuff": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: organizing_school_stuff\n## Relevant objects in this scene\n{'name': 'highlighter.102', 'category': 'highlighter_n_02'}\n{'name': 'bed.58', 'category': 'bed_n_01'}\n{'name': 'pencil.103', 'category': 'pencil_n_01'}\n{'name': 'pen.104', 'category': 'pen_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'calculator.105', 'category': 'calculator_n_02'}\n{'name': 'hardback.106', 'category': 'book_n_02'}\n{'name': 'folder.107', 'category': 'folder_n_02'}\n{'name': 'breakfast_table.21', 'category': 'table_n_02'}\n{'name': 'backpack.108', 'category': 'backpack_n_01'}\n\n## Initial States\nontop(highlighter.102, bed.58)\nontop(pencil.103, bed.58)\nonfloor(pen.104, room_floor_bedroom.0)\nonfloor(calculator.105, room_floor_bedroom.0)\nontop(hardback.106, bed.58)\nontop(folder.107, bed.58)\nonfloor(backpack.108, room_floor_bedroom.0)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nnextto(folder.107, hardback.106) and nextto(folder.107, backpack.108) and nextto(hardback.106, backpack.108)\ninside(highlighter.102, backpack.108)\ninside(pencil.103, backpack.108)\ninside(pen.104, backpack.108)\ninside(calculator.105, backpack.108)\nontop(backpack.108, bed.58)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(backpack.108)\", \"ontop(backpack.108, bed.58)\", \"holds_rh(highlighter.102)\", \"inside(highlighter.102, backpack.108)\", \"holds_rh(pencil.103)\", \"inside(pencil.103, backpack.108)\", \"holds_rh(pen.104)\", \"inside(pen.104, backpack.108)\", \"holds_rh(calculator.105)\", \"inside(calculator.105, backpack.108)\", \"nextto(folder.107, hardback.106) and nextto(folder.107, backpack.108) and nextto(hardback.106, backpack.108)\"]}\n```"
    },
    "packing_adult_s_bags": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_adult_s_bags\n## Relevant objects in this scene\n{'name': 'backpack.112', 'category': 'backpack_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_corridor.0', 'category': 'floor_n_01'}\n{'name': 'hanger.113', 'category': 'hanger_n_02'}\n{'name': 'bed.33', 'category': 'bed_n_01'}\n{'name': 'lipstick.114', 'category': 'makeup_n_01'}\n{'name': 'lipstick.115', 'category': 'makeup_n_01'}\n{'name': 'bracelet.116', 'category': 'jewelry_n_01'}\n{'name': 'necklace.117', 'category': 'jewelry_n_01'}\n{'name': 'toothbrush.118', 'category': 'toothbrush_n_01'}\n{'name': 'mouse.119', 'category': 'mouse_n_04'}\n{'name': 'door.99', 'category': 'door_n_01'}\n\n## Initial States\nonfloor(backpack.112, room_floor_bedroom.0)\nontop(hanger.113, bed.33)\nontop(lipstick.114, bed.33)\nontop(lipstick.115, bed.33)\nontop(toothbrush.118, bed.33)\nonfloor(bracelet.116, room_floor_bedroom.0)\nonfloor(necklace.117, room_floor_bedroom.0)\nontop(mouse.119, bed.33)\nopen(door.99)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(jewelry_n_01, inside(jewelry_n_01, backpack.112))\nforall(makeup_n_01, inside(makeup_n_01, backpack.112))\ninside(toothbrush.118, backpack.112)\ninside(mouse.119, backpack.112)\nonfloor(backpack.112, room_floor_corridor.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(backpack.112)\", \"ontop(backpack.112, bed.33)\", \"holds_rh(hanger.113)\", \"inside(hanger.113, backpack.112)\", \"holds_rh(lipstick.114)\", \"inside(lipstick.114, backpack.112)\", \"holds_rh(lipstick.115)\", \"inside(lipstick.115, backpack.112)\", \"holds_rh(toothbrush.118)\", \"inside(toothbrush.118, backpack.112)\", \"holds_rh(mouse.119)\", \"inside(mouse.119, backpack.112)\", \"holds_rh(bracelet.116)\", \"inside(bracelet.116, backpack.112)\", \"holds_rh(necklace.117)\", \"inside(necklace.117, backpack.112)\", \"holds_rh(backpack.112)\", \"onfloor(backpack.112, room_floor_corridor.0)\"]}"
    },
    "packing_bags_or_suitcase": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_bags_or_suitcase\n## Relevant objects in this scene\n{'name': 'backpack.97', 'category': 'backpack_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'toothbrush.98', 'category': 'toothbrush_n_01'}\n{'name': 'bed.7', 'category': 'bed_n_01'}\n{'name': 'shampoo.99', 'category': 'shampoo_n_01'}\n{'name': 'hardback.100', 'category': 'hardback_n_01'}\n{'name': 'underwear.101', 'category': 'underwear_n_01'}\n{'name': 'underwear.102', 'category': 'underwear_n_01'}\n{'name': 'toothpaste.103', 'category': 'toothpaste_n_01'}\n{'name': 'door.85', 'category': 'door_n_01'}\n{'name': 'window.79', 'category': 'window_n_01'}\n\n## Initial States\nonfloor(backpack.97, room_floor_bedroom.0)\nontop(toothbrush.98, bed.7)\nontop(shampoo.99, bed.7)\nontop(hardback.100, bed.7)\nontop(underwear.101, bed.7)\nontop(underwear.102, bed.7)\nontop(toothpaste.103, bed.7)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nforall(underwear_n_01, inside(underwear_n_01, backpack.97))\ninside(toothbrush.98, backpack.97)\ninside(shampoo.99, backpack.97)\ninside(hardback.100, backpack.97)\ninside(toothpaste.103, backpack.97)\nontop(backpack.97, bed.7) or onfloor(backpack.97, room_floor_bedroom.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(backpack.97)\", \"ontop(backpack.97, bed.7)\", \"holds_rh(toothbrush.98)\", \"inside(toothbrush.98, backpack.97)\", \"holds_rh(shampoo.99)\", \"inside(shampoo.99, backpack.97)\", \"holds_rh(hardback.100)\", \"inside(hardback.100, backpack.97)\", \"holds_rh(underwear.101)\", \"inside(underwear.101, backpack.97)\", \"holds_rh(underwear.102)\", \"inside(underwear.102, backpack.97)\", \"holds_rh(toothpaste.103)\", \"inside(toothpaste.103, backpack.97)\"]}"
    },
    "packing_boxes_for_household_move_or_trip": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_boxes_for_household_move_or_trip\n## Relevant objects in this scene\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'carton.1', 'category': 'carton_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'notebook.0', 'category': 'book_n_02'}\n{'name': 'hardback.0', 'category': 'book_n_02'}\n{'name': 'coffee_table.26', 'category': 'table_n_02'}\n{'name': 'sweater.0', 'category': 'sweater_n_01'}\n{'name': 't-shirt.0', 'category': 'shirt_n_01'}\n{'name': 't-shirt.1', 'category': 'shirt_n_01'}\n{'name': 'plate.0', 'category': 'plate_n_04'}\n{'name': 'plate.1', 'category': 'plate_n_04'}\n{'name': 'plate.2', 'category': 'plate_n_04'}\n{'name': 'plate.3', 'category': 'plate_n_04'}\n{'name': 'dishtowel.0', 'category': 'dishtowel_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_living_room.0)\nonfloor(carton.1, room_floor_living_room.0)\nontop(hardback.0, coffee_table.26)\nontop(notebook.0, coffee_table.26)\nonfloor(sweater.0, room_floor_living_room.0)\nonfloor(t-shirt.0, room_floor_living_room.0)\nonfloor(t-shirt.1, room_floor_living_room.0)\nontop(plate.0, coffee_table.26)\nonfloor(plate.1, room_floor_living_room.0)\nonfloor(plate.2, room_floor_living_room.0)\nonfloor(plate.3, room_floor_living_room.0)\nonfloor(dishtowel.0, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nexists(carton_n_02, (forall(plate_n_04, inside(plate_n_04, carton_n_02)) and inside(dishtowel.0, carton_n_02)))\nexists(carton_n_02, (forall(book_n_02, inside(book_n_02, carton_n_02)) and forall(shirt_n_01, inside(shirt_n_01, carton_n_02)) and inside(sweater.0, carton_n_02)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(hardback.0)\", \"inside(hardback.0, carton.0)\", \"holds_rh(notebook.0)\", \"inside(notebook.0, carton.0)\", \"holds_rh(t-shirt.0)\", \"inside(t-shirt.0, carton.0)\", \"holds_rh(t-shirt.1)\", \"inside(t-shirt.1, carton.0)\", \"holds_rh(sweater.0)\", \"inside(sweater.0, carton.0)\", \"holds_rh(plate.0)\", \"inside(plate.0, carton.1)\", \"holds_rh(plate.1)\", \"inside(plate.1, carton.1)\", \"holds_rh(plate.2)\", \"inside(plate.2, carton.1)\", \"holds_rh(plate.3)\", \"inside(plate.3, carton.1)\", \"holds_rh(dishtowel.0)\", \"inside(dishtowel.0, carton.1)\"]}\n```"
    },
    "packing_car_for_trip": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_car_for_trip\n## Relevant objects in this scene\n{'name': 'car.50', 'category': 'car_n_01'}\n{'name': 'briefcase.51', 'category': 'briefcase_n_01'}\n{'name': 'pencil_box.52', 'category': 'pencil_box_n_01'}\n{'name': 'headset.53', 'category': 'headset_n_01'}\n{'name': 'duffel_bag.54', 'category': 'duffel_bag_n_01'}\n{'name': 'breakfast_table.14', 'category': 'table_n_02'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_storage_room.0', 'category': 'floor_n_01'}\n\n## Initial States\nonfloor(car.50, room_floor_garage.0)\nonfloor(briefcase.51, room_floor_storage_room.0)\nontop(pencil_box.52, breakfast_table.14)\nontop(headset.53, breakfast_table.14)\nonfloor(duffel_bag.54, room_floor_storage_room.0)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\ninside(briefcase.51, car.50)\ninside(pencil_box.52, car.50)\ninside(headset.53, car.50)\ninside(duffel_bag.54, car.50)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(briefcase.51)\", \"ontop(briefcase.51, breakfast_table.14)\", \"holds_rh(pencil_box.52)\", \"inside(pencil_box.52, briefcase.51)\", \"holds_rh(headset.53)\", \"inside(headset.53, briefcase.51)\", \"holds_rh(duffel_bag.54)\", \"inside(duffel_bag.54, briefcase.51)\", \"holds_rh(briefcase.51)\", \"inside(briefcase.51, car.50)\"]}"
    },
    "packing_child_s_bag": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_child_s_bag\n## Relevant objects in this scene\n{'name': 'backpack.100', 'category': 'backpack_n_01'}\n{'name': 'notebook.101', 'category': 'notebook_n_01'}\n{'name': 'bracelet.102', 'category': 'bracelet_n_02'}\n{'name': 'apple.103', 'category': 'apple_n_01'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'bed.43', 'category': 'bed_n_01'}\n{'name': 'headset.104', 'category': 'earphone_n_01'}\n{'name': 'sunglass.105', 'category': 'sunglass_n_01'}\n\n## Initial States\nonfloor(backpack.100, room_floor_bedroom.0)\nontop(sunglass.105, bed.43)\nontop(bracelet.102, bed.43)\nonfloor(notebook.101, room_floor_bedroom.0)\nontop(apple.103, bed.43)\nontop(headset.104, bed.43)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nnextto(backpack.100, bed.43)\ninside(sunglass.105, backpack.100)\ninside(notebook.101, backpack.100)\ninside(bracelet.102, backpack.100)\ninside(apple.103, backpack.100)\ninside(headset.104, backpack.100)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(backpack.100)\", \"nextto(backpack.100, bed.43)\", \"holds_lh(sunglass.105)\", \"inside(sunglass.105, backpack.100)\", \"holds_lh(notebook.101)\", \"inside(notebook.101, backpack.100)\", \"holds_lh(bracelet.102)\", \"inside(bracelet.102, backpack.100)\", \"holds_lh(apple.103)\", \"inside(apple.103, backpack.100)\", \"holds_lh(headset.104)\", \"inside(headset.104, backpack.100)\"]}\n```"
    },
    "packing_food_for_work": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_food_for_work\n## Relevant objects in this scene\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'countertop.81', 'category': 'countertop_n_01'}\n{'name': 'hamburger.0', 'category': 'sandwich_n_01'}\n{'name': 'fridge.61', 'category': 'electric_refrigerator_n_01'}\n{'name': 'apple.0', 'category': 'apple_n_01'}\n{'name': 'hamburger.1', 'category': 'snack_food_n_01'}\n{'name': 'top_cabinet.62', 'category': 'cabinet_n_01'}\n{'name': 'juice.0', 'category': 'juice_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'door.91', 'category': 'door_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_kitchen.0)\ninside(hamburger.0, fridge.61)\nontop(apple.0, countertop.81)\ninside(hamburger.1, top_cabinet.62)\nontop(juice.0, countertop.81)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\ninside(hamburger.0, carton.0)\ninside(apple.0, carton.0)\ninside(hamburger.1, carton.0)\ninside(juice.0, carton.0)\nonfloor(carton.0, room_floor_kitchen.0) or ontop(carton.0, countertop.81)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(carton.0)\", \"ontop(carton.0, countertop.81)\", \"holds_rh(hamburger.0)\", \"ontop(hamburger.0, countertop.81)\", \"holds_rh(apple.0)\", \"inside(apple.0, carton.0)\", \"holds_rh(hamburger.0)\", \"inside(hamburger.0, carton.0)\", \"holds_rh(hamburger.1)\", \"ontop(hamburger.1, countertop.81)\", \"holds_rh(juice.0)\", \"inside(juice.0, carton.0)\", \"holds_rh(hamburger.1)\", \"inside(hamburger.1, carton.0)\", \"ontop(carton.0, countertop.81) or onfloor(carton.0, room_floor_kitchen.0)\"]}"
    },
    "packing_lunches": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_lunches\n## Relevant objects in this scene\n{'name': 'salad.0', 'category': 'salad_n_01'}\n{'name': 'fridge.57', 'category': 'electric_refrigerator_n_01'}\n{'name': 'hamburger.0', 'category': 'sandwich_n_01'}\n{'name': 'chip.0', 'category': 'chip_n_04'}\n{'name': 'chip.1', 'category': 'chip_n_04'}\n{'name': 'bottom_cabinet_no_top.54', 'category': 'cabinet_n_01'}\n{'name': 'juice.0', 'category': 'juice_n_01'}\n{'name': 'breakfast_table.7', 'category': 'table_n_02'}\n{'name': 'pop.0', 'category': 'pop_n_02'}\n{'name': 'apple.0', 'category': 'apple_n_01'}\n{'name': 'countertop.56', 'category': 'countertop_n_01'}\n{'name': 'banana.0', 'category': 'banana_n_02'}\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'carton.1', 'category': 'carton_n_02'}\n{'name': 'cookie.0', 'category': 'cookie_n_01'}\n{'name': 'cookie.1', 'category': 'cookie_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(salad.0, fridge.57)\ninside(hamburger.0, fridge.57)\ninside(chip.0, bottom_cabinet_no_top.54)\ninside(chip.1, bottom_cabinet_no_top.54)\nontop(juice.0, breakfast_table.7)\nontop(pop.0, breakfast_table.7)\nontop(apple.0, countertop.56)\nontop(banana.0, countertop.56)\nonfloor(carton.0, room_floor_living_room.0)\nonfloor(carton.1, room_floor_living_room.0)\nontop(cookie.0, countertop.56)\nontop(cookie.1, countertop.56)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforpairs(chip_n_04, carton_n_02, inside(chip_n_04, carton_n_02))\nforpairs(cookie_n_01, carton_n_02, inside(cookie_n_01, carton_n_02))\nexists(carton_n_02, (inside(salad.0, carton_n_02) and inside(juice.0, carton_n_02) and (not inside(hamburger.0, carton_n_02))))\nexists(carton_n_02, (inside(hamburger.0, carton_n_02) and inside(pop.0, carton_n_02) and (not inside(salad.0, carton_n_02))))\ninside(apple.0, carton.0) or inside(banana.0, carton.0)\ninside(apple.0, carton.1) or inside(banana.0, carton.1)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"ontop(salad.0, countertop.56) and ontop(hamburger.0, countertop.56)\", \"holds_rh(carton.0)\", \"ontop(carton.0, countertop.56)\", \"holds_rh(carton.1)\", \"ontop(carton.1, countertop.56)\", \"holds_rh(cookie.0)\", \"inside(cookie.0, carton.0)\", \"holds_rh(cookie.1)\", \"inside(cookie.1, carton.1)\", \"holds_rh(chip.0)\", \"inside(chip.0, carton.0)\", \"holds_rh(chip.1)\", \"inside(chip.1, carton.1)\", \"holds_rh(salad.0)\", \"inside(salad.0, carton.0)\", \"holds_rh(juice.0)\", \"inside(juice.0, carton.0)\", \"holds_rh(hamburger.0)\", \"inside(hamburger.0, carton.1)\", \"holds_rh(pop.0)\", \"inside(pop.0, carton.1)\", \"holds_rh(apple.0)\", \"inside(apple.0, carton.0) or inside(apple.0, carton.1)\", \"holds_rh(banana.0)\", \"inside(banana.0, carton.0) or inside(banana.0, carton.1)\"]}\n```"
    },
    "packing_picnics": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: packing_picnics\n## Relevant objects in this scene\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'carton.1', 'category': 'carton_n_02'}\n{'name': 'carton.2', 'category': 'carton_n_02'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'chip.0', 'category': 'chip_n_04'}\n{'name': 'chip.1', 'category': 'chip_n_04'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'hamburger.0', 'category': 'sandwich_n_01'}\n{'name': 'hamburger.1', 'category': 'sandwich_n_01'}\n{'name': 'hamburger.2', 'category': 'sandwich_n_01'}\n{'name': 'hamburger.3', 'category': 'sandwich_n_01'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'cantaloup.0', 'category': 'melon_n_01'}\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'strawberry.1', 'category': 'strawberry_n_01'}\n{'name': 'strawberry.2', 'category': 'strawberry_n_01'}\n{'name': 'strawberry.3', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'grape.0', 'category': 'grape_n_01'}\n{'name': 'grape.1', 'category': 'grape_n_01'}\n{'name': 'grape.2', 'category': 'grape_n_01'}\n{'name': 'grape.3', 'category': 'grape_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'peach.1', 'category': 'peach_n_03'}\n{'name': 'pop.0', 'category': 'pop_n_02'}\n{'name': 'pop.1', 'category': 'pop_n_02'}\n{'name': 'beer.0', 'category': 'beer_n_01'}\n{'name': 'beer.1', 'category': 'beer_n_01'}\n{'name': 'water.0', 'category': 'water_n_06'}\n{'name': 'water.1', 'category': 'water_n_06'}\n{'name': 'water.2', 'category': 'water_n_06'}\n{'name': 'water.3', 'category': 'water_n_06'}\n{'name': 'sink.82', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_kitchen.0)\nonfloor(carton.1, room_floor_living_room.0)\nonfloor(carton.2, room_floor_living_room.0)\ninside(chip.0, bottom_cabinet_no_top.80)\ninside(chip.1, bottom_cabinet_no_top.80)\nontop(hamburger.0, countertop.84)\nontop(hamburger.1, countertop.84)\nontop(hamburger.2, countertop.84)\nontop(hamburger.3, countertop.84)\nontop(cantaloup.0, countertop.84)\ninside(strawberry.0, fridge.97)\ninside(strawberry.1, fridge.97)\ninside(strawberry.2, fridge.97)\ninside(strawberry.3, fridge.97)\ninside(grape.0, fridge.97)\ninside(grape.1, fridge.97)\ninside(grape.2, fridge.97)\ninside(grape.3, fridge.97)\ninside(peach.0, fridge.97)\ninside(peach.1, fridge.97)\ninside(pop.0, fridge.97)\ninside(pop.1, fridge.97)\ninside(beer.0, fridge.97)\ninside(beer.1, fridge.97)\ninside(water.0, bottom_cabinet_no_top.80)\ninside(water.1, bottom_cabinet_no_top.80)\ninside(water.2, bottom_cabinet_no_top.80)\ninside(water.3, bottom_cabinet_no_top.80)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(carton_n_02, (forall(chip_n_04, inside(chip_n_04, carton_n_02)) and forall(sandwich_n_01, inside(sandwich_n_01, carton_n_02))))\nexists(carton_n_02, (forall(strawberry_n_01, inside(strawberry_n_01, carton_n_02)) and forall(grape_n_01, inside(grape_n_01, carton_n_02)) and forall(peach_n_03, inside(peach_n_03, carton_n_02)) and nextto(cantaloup.0, carton_n_02)))\nexists(carton_n_02, (forall(pop_n_02, inside(pop_n_02, carton_n_02)) and forall(beer_n_01, inside(beer_n_01, carton_n_02)) and forall(water_n_06, inside(water_n_06, carton_n_02))))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(fridge.97) and open(bottom_cabinet_no_top.80)\", \"holds_rh(chip.0) and holds_lh(chip.1)\", \"inside(chip.0, carton.0) and inside(chip.1, carton.0)\", \"holds_rh(hamburger.0) and holds_lh(hamburger.1)\", \"inside(hamburger.0, carton.0) and inside(hamburger.1, carton.0)\", \"holds_rh(hamburger.2) and holds_lh(hamburger.3)\", \"inside(hamburger.2, carton.0) and inside(hamburger.3, carton.0)\", \"holds_rh(strawberry.0) and holds_lh(strawberry.1)\", \"inside(strawberry.0, carton.1) and inside(strawberry.1, carton.1)\", \"holds_rh(strawberry.2) and holds_lh(strawberry.3)\", \"inside(strawberry.2, carton.1) and inside(strawberry.3, carton.1)\", \"holds_rh(grape.0) and holds_lh(grape.1)\", \"inside(grape.0, carton.1) and inside(grape.1, carton.1)\", \"holds_rh(grape.2) and holds_lh(grape.3)\", \"inside(grape.2, carton.1) and inside(grape.3, carton.1)\", \"holds_rh(peach.0) and holds_lh(peach.1)\", \"inside(peach.0, carton.1) and inside(peach.1, carton.1)\", \"nextto(cantaloup.0, carton.1)\", \"holds_rh(pop.0) and holds_lh(pop.1)\", \"inside(pop.0, carton.2) and inside(pop.1, carton.2)\", \"holds_rh(beer.0) and holds_lh(beer.1)\", \"inside(beer.0, carton.2) and inside(beer.1, carton.2)\", \"holds_rh(water.0) and holds_lh(water.1)\", \"inside(water.0, carton.2) and inside(water.1, carton.2)\", \"holds_rh(water.2) and holds_lh(water.3)\", \"inside(water.2, carton.2) and inside(water.3, carton.2)\"]}"
    },
    "picking_up_take-out_food": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: picking_up_take-out_food\n## Relevant objects in this scene\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'breakfast_table.19', 'category': 'table_n_02'}\n{'name': 'sushi.0', 'category': 'sushi_n_01'}\n{'name': 'hamburger.0', 'category': 'hamburger_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_living_room.0)\ninside(sushi.0, carton.0)\ninside(hamburger.0, carton.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(carton_n_02, ontop(carton_n_02, breakfast_table.19))\ninside(sushi.0, carton.0)\ninside(hamburger.0, carton.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(carton.0)\", \"ontop(carton.0, breakfast_table.19)\", \"inside(sushi.0, carton.0) and inside(hamburger.0, carton.0)\"]}"
    },
    "picking_up_trash": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: picking_up_trash\n## Relevant objects in this scene\n{'name': 'trash_can.116', 'category': 'ashcan_n_01'}\n{'name': 'sticky_note.117', 'category': 'pad_n_01'}\n{'name': 'sticky_note.118', 'category': 'pad_n_01'}\n{'name': 'sticky_note.119', 'category': 'pad_n_01'}\n{'name': 'pop.120', 'category': 'pop_n_02'}\n{'name': 'pop.121', 'category': 'pop_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nonfloor(trash_can.116, room_floor_kitchen.0)\nonfloor(sticky_note.117, room_floor_kitchen.0)\nonfloor(sticky_note.118, room_floor_kitchen.0)\nonfloor(sticky_note.119, room_floor_living_room.0)\nonfloor(pop.120, room_floor_living_room.0)\nonfloor(pop.121, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(pad_n_01, inside(pad_n_01, trash_can.116))\nforall(pop_n_02, inside(pop_n_02, trash_can.116))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(sticky_note.117)\", \"inside(sticky_note.117, trash_can.116)\", \"holds_rh(sticky_note.118)\", \"inside(sticky_note.118, trash_can.116)\", \"holds_rh(sticky_note.119)\", \"inside(sticky_note.119, trash_can.116)\", \"holds_rh(pop.120)\", \"inside(pop.120, trash_can.116)\", \"holds_rh(pop.121)\", \"inside(pop.121, trash_can.116)\"]}"
    },
    "polishing_furniture": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: polishing_furniture\n## Relevant objects in this scene\n{'name': 'shelf.11', 'category': 'shelf_n_01'}\n{'name': 'coffee_table.10', 'category': 'table_n_02'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n\n## Initial States\ndusty(shelf.11)\ndusty(coffee_table.10)\nontop(rag.0, coffee_table.10)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nnot dusty(coffee_table.10)\nnot dusty(shelf.11)\nunder(rag.0, coffee_table.10)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n    \"output\": [\n        \"holds_rh(rag.0)\",\n        \"not dusty(coffee_table.10) and not dusty(shelf.11)\",\n        \"under(rag.0, coffee_table.10)\"\n    ]\n}"
    },
    "polishing_shoes": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: polishing_shoes\n## Relevant objects in this scene\n{'name': 'sandal.143', 'category': 'shoe_n_01'}\n{'name': 'walker.144', 'category': 'shoe_n_01'}\n{'name': 'rag.145', 'category': 'rag_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'sink.67', 'category': 'sink_n_01'}\n\n## Initial States\nstained(sandal.143)\nstained(walker.144)\nonfloor(rag.145, room_floor_bathroom.0)\nnot soaked(rag.145)\nonfloor(sandal.143, room_floor_bathroom.0)\nonfloor(walker.144, room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnextto(rag.145, sink.67)\nsoaked(rag.145)\n(not stained(sandal.143)) and (not stained(walker.144))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"nextto(rag.145, sink.67)\", \"holds_rh(rag.145)\", \"inside(rag.145, sink.67)\", \"toggledon(sink.67)\", \"soaked(rag.145)\", \"holds_rh(rag.145)\", \"not stained(sandal.143)\", \"not stained(walker.144)\"]}\n```"
    },
    "polishing_silver": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: polishing_silver\n## Relevant objects in this scene\n{'name': 'spoon.97', 'category': 'spoon_n_01'}\n{'name': 'spoon.98', 'category': 'spoon_n_01'}\n{'name': 'spoon.99', 'category': 'spoon_n_01'}\n{'name': 'spoon.100', 'category': 'spoon_n_01'}\n{'name': 'rag.101', 'category': 'rag_n_01'}\n{'name': 'bottom_cabinet.49', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ndusty(spoon.97)\ndusty(spoon.98)\ndusty(spoon.99)\ndusty(spoon.100)\ninside(rag.101, bottom_cabinet.49)\ninside(spoon.97, bottom_cabinet.49)\ninside(spoon.98, bottom_cabinet.49)\ninside(spoon.99, bottom_cabinet.49)\ninside(spoon.100, bottom_cabinet.49)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnot dusty(spoon.97)\nnot dusty(spoon.98)\nnot dusty(spoon.99)\nnot dusty(spoon.100)\nnot inside(rag.101, bottom_cabinet.49)\ninside(spoon.97, bottom_cabinet.49)\ninside(spoon.98, bottom_cabinet.49)\ninside(spoon.99, bottom_cabinet.49)\ninside(spoon.100, bottom_cabinet.49)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n    \"output\": [\n        \"open(bottom_cabinet.49)\",\n        \"ontop(rag.101, bottom_cabinet.49) and ontop(spoon.97, bottom_cabinet.49) and ontop(spoon.98, bottom_cabinet.49) and ontop(spoon.99, bottom_cabinet.49) and ontop(spoon.100, bottom_cabinet.49)\",\n        \"holds_rh(rag.101)\",\n        \"holds_rh(rag.101) and not dusty(spoon.97)\",\n        \"holds_rh(rag.101) and not dusty(spoon.98)\",\n        \"holds_rh(rag.101) and not dusty(spoon.99)\",\n        \"holds_rh(rag.101) and not dusty(spoon.100)\",\n        \"inside(spoon.97, bottom_cabinet.49) and inside(spoon.98, bottom_cabinet.49) and inside(spoon.99, bottom_cabinet.49) and inside(spoon.100, bottom_cabinet.49)\",\n        \"not open(bottom_cabinet.49)\"\n    ]\n}"
    },
    "preparing_a_shower_for_child": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: preparing_a_shower_for_child\n## Relevant objects in this scene\n{'name': 'shampoo.0', 'category': 'shampoo_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'dishtowel.0', 'category': 'towel_n_01'}\n{'name': 'shower.35', 'category': 'shower_n_01'}\n{'name': 'sink.38', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(shampoo.0, room_floor_bathroom.0)\nonfloor(soap.0, room_floor_bathroom.0)\nonfloor(dishtowel.0, room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nonfloor(dishtowel.0, room_floor_bathroom.0)\nonfloor(shampoo.0, room_floor_bathroom.0)\nnextto(soap.0, sink.38)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(soap.0)\", \"nextto(soap.0, sink.38)\"]}"
    },
    "preparing_salad": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: preparing_salad\n## Relevant objects in this scene\n{'name': 'fridge.20', 'category': 'electric_refrigerator_n_01'}\n{'name': 'lettuce.78', 'category': 'lettuce_n_03'}\n{'name': 'lettuce.79', 'category': 'lettuce_n_03'}\n{'name': 'countertop.31', 'category': 'countertop_n_01'}\n{'name': 'apple.80', 'category': 'apple_n_01'}\n{'name': 'apple.81', 'category': 'apple_n_01'}\n{'name': 'tomato.82', 'category': 'tomato_n_01'}\n{'name': 'tomato.83', 'category': 'tomato_n_01'}\n{'name': 'radish.84', 'category': 'radish_n_01'}\n{'name': 'radish.85', 'category': 'radish_n_01'}\n{'name': 'carving_knife.86', 'category': 'carving_knife_n_01'}\n{'name': 'plate.87', 'category': 'plate_n_04'}\n{'name': 'plate.88', 'category': 'plate_n_04'}\n{'name': 'top_cabinet.27', 'category': 'cabinet_n_01'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(lettuce.78, countertop.31)\nontop(lettuce.79, countertop.31)\nontop(apple.80, countertop.31)\nontop(apple.81, countertop.31)\ninside(tomato.82, fridge.20)\ninside(tomato.83, fridge.20)\nontop(radish.84, countertop.31)\nontop(radish.85, countertop.31)\ninside(plate.87, top_cabinet.27)\nnot dusty(plate.87)\ninside(plate.88, top_cabinet.27)\nnot dusty(plate.88)\ninside(carving_knife.86, top_cabinet.27)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforpairs(lettuce_n_03, plate_n_04, ontop(lettuce_n_03, plate_n_04))\nforpairs(apple_n_01, plate_n_04, (sliced(apple_n_01) and ontop(apple_n_01, plate_n_04)))\nforpairs(tomato_n_01, plate_n_04, (ontop(tomato_n_01, plate_n_04) and sliced(tomato_n_01)))\nforpairs(radish_n_01, plate_n_04, ontop(radish_n_01, plate_n_04))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"ontop(carving_knife.86, countertop.31)\", \"ontop(plate.87, countertop.31) and ontop(plate.88, countertop.31)\", \"holds_rh(carving_knife.86)\", \"sliced(apple.80) and sliced(apple.81)\", \"sliced(tomato.82) and sliced(tomato.83)\", \"ontop(lettuce.78, plate.87) and ontop(lettuce.79, plate.88)\", \"ontop(apple.80, plate.87) and ontop(apple.81, plate.88)\", \"ontop(tomato.82, plate.87) and ontop(tomato.83, plate.88)\", \"ontop(radish.84, plate.87) and ontop(radish.85, plate.88)\"]}\n```"
    },
    "preserving_food": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: preserving_food\n## Relevant objects in this scene\n{'name': 'strawberry.61', 'category': 'strawberry_n_01'}\n{'name': 'strawberry.62', 'category': 'strawberry_n_01'}\n{'name': 'beef.63', 'category': 'beef_n_02'}\n{'name': 'jar.64', 'category': 'jar_n_01'}\n{'name': 'saucepan.65', 'category': 'pan_n_01'}\n{'name': 'fridge.40', 'category': 'electric_refrigerator_n_01'}\n{'name': 'bottom_cabinet.41', 'category': 'cabinet_n_01'}\n{'name': 'countertop.26', 'category': 'countertop_n_01'}\n{'name': 'carving_knife.66', 'category': 'carving_knife_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(strawberry.61, countertop.26)\nontop(strawberry.62, countertop.26)\nontop(beef.63, countertop.26)\nontop(jar.64, countertop.26)\nopen(jar.64)\nontop(saucepan.65, countertop.26)\nontop(carving_knife.66, countertop.26)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(strawberry_n_01, sliced(strawberry_n_01))\nforall(strawberry_n_01, cooked(strawberry_n_01))\nforall(strawberry_n_01, inside(strawberry_n_01, jar.64))\nnot open(jar.64)\ninside(beef.63, fridge.40)\nfrozen(beef.63)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(carving_knife.66)\", \"sliced(strawberry.61) and sliced(strawberry.62)\", \"holds_rh(strawberry.61)\", \"ontop(strawberry.61, saucepan.65)\", \"holds_rh(strawberry.62)\", \"ontop(strawberry.62, saucepan.65)\", \"toggledon(saucepan.65)\", \"cooked(strawberry.61) and cooked(strawberry.62)\", \"holds_rh(strawberry.61)\", \"inside(strawberry.61, jar.64)\", \"holds_rh(strawberry.62)\", \"inside(strawberry.62, jar.64)\", \"not open(jar.64)\", \"holds_rh(beef.63)\", \"inside(beef.63, fridge.40)\", \"frozen(beef.63)\"]}"
    },
    "putting_away_Christmas_decorations": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: putting_away_Christmas_decorations\n## Relevant objects in this scene\n{'name': 'wreath.0', 'category': 'wreath_n_01'}\n{'name': 'wreath.1', 'category': 'wreath_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'bow.0', 'category': 'bow_n_08'}\n{'name': 'bow.1', 'category': 'bow_n_08'}\n{'name': 'bow.2', 'category': 'bow_n_08'}\n{'name': 'ribbon.0', 'category': 'ribbon_n_01'}\n{'name': 'ribbon.1', 'category': 'ribbon_n_01'}\n{'name': 'ribbon.2', 'category': 'ribbon_n_01'}\n{'name': 'bottom_cabinet.79', 'category': 'cabinet_n_01'}\n\n## Initial States\nonfloor(wreath.0, room_floor_living_room.0)\nonfloor(wreath.1, room_floor_living_room.0)\nonfloor(bow.0, room_floor_living_room.0)\nonfloor(bow.1, room_floor_living_room.0)\nonfloor(bow.2, room_floor_living_room.0)\nonfloor(ribbon.0, room_floor_living_room.0)\nonfloor(ribbon.1, room_floor_living_room.0)\nonfloor(ribbon.2, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(wreath_n_01, nextto(wreath_n_01, bottom_cabinet.79))\nforall(bow_n_08, nextto(bow_n_08, bottom_cabinet.79))\nforall(ribbon_n_01, inside(ribbon_n_01, bottom_cabinet.79))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(wreath.0)\", \"nextto(wreath.0, bottom_cabinet.79)\", \"holds_rh(wreath.1)\", \"nextto(wreath.1, bottom_cabinet.79)\", \"holds_rh(bow.0)\", \"nextto(bow.0, bottom_cabinet.79)\", \"holds_rh(bow.1)\", \"nextto(bow.1, bottom_cabinet.79)\", \"holds_rh(bow.2)\", \"nextto(bow.2, bottom_cabinet.79)\", \"open(bottom_cabinet.79)\", \"holds_rh(ribbon.0)\", \"inside(ribbon.0, bottom_cabinet.79)\", \"holds_rh(ribbon.1)\", \"inside(ribbon.1, bottom_cabinet.79)\", \"holds_rh(ribbon.2)\", \"inside(ribbon.2, bottom_cabinet.79)\", \"not open(bottom_cabinet.79)\"]}"
    },
    "putting_away_Halloween_decorations": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: putting_away_Halloween_decorations\n## Relevant objects in this scene\n{'name': 'pumpkin.0', 'category': 'pumpkin_n_02'}\n{'name': 'pumpkin.1', 'category': 'pumpkin_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'cauldron.0', 'category': 'caldron_n_01'}\n{'name': 'sheet.0', 'category': 'sheet_n_03'}\n{'name': 'coffee_table.5', 'category': 'table_n_02'}\n{'name': 'candle.0', 'category': 'candle_n_01'}\n{'name': 'candle.1', 'category': 'candle_n_01'}\n{'name': 'candle.2', 'category': 'candle_n_01'}\n{'name': 'bottom_cabinet.13', 'category': 'cabinet_n_01'}\n{'name': 'sofa.2', 'category': 'sofa_n_01'}\n\n## Initial States\nonfloor(pumpkin.0, room_floor_living_room.0)\nonfloor(pumpkin.1, room_floor_living_room.0)\nonfloor(cauldron.0, room_floor_living_room.0)\nontop(sheet.0, coffee_table.5)\nonfloor(candle.0, room_floor_living_room.0)\nonfloor(candle.1, room_floor_living_room.0)\nonfloor(candle.2, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(pumpkin_n_02, inside(pumpkin_n_02, bottom_cabinet.13))\nforall(candle_n_01, inside(candle_n_01, bottom_cabinet.13))\nnextto(sheet.0, coffee_table.5) or ontop(sheet.0, coffee_table.5)\nnextto(cauldron.0, coffee_table.5)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"ontop(sheet.0, coffee_table.5)\", \"open(bottom_cabinet.13)\", \"holds_rh(pumpkin.0)\", \"inside(pumpkin.0, bottom_cabinet.13)\", \"holds_rh(pumpkin.1)\", \"inside(pumpkin.1, bottom_cabinet.13)\", \"holds_rh(candle.0)\", \"inside(candle.0, bottom_cabinet.13)\", \"holds_rh(candle.1)\", \"inside(candle.1, bottom_cabinet.13)\", \"holds_rh(candle.2)\", \"inside(candle.2, bottom_cabinet.13)\", \"not open(bottom_cabinet.13)\", \"nextto(cauldron.0, coffee_table.5)\"]}"
    },
    "putting_away_toys": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: putting_away_toys\n## Relevant objects in this scene\n{'name': 'toy.0', 'category': 'plaything_n_01'}\n{'name': 'toy.1', 'category': 'plaything_n_01'}\n{'name': 'toy.2', 'category': 'plaything_n_01'}\n{'name': 'toy.3', 'category': 'plaything_n_01'}\n{'name': 'toy.4', 'category': 'plaything_n_01'}\n{'name': 'toy.5', 'category': 'plaything_n_01'}\n{'name': 'toy.6', 'category': 'plaything_n_01'}\n{'name': 'toy.7', 'category': 'plaything_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'carton.1', 'category': 'carton_n_02'}\n{'name': 'breakfast_table.2', 'category': 'table_n_02'}\n\n## Initial States\nonfloor(toy.0, room_floor_living_room.0)\nonfloor(toy.1, room_floor_living_room.0)\nonfloor(toy.2, room_floor_living_room.0)\nonfloor(toy.3, room_floor_living_room.0)\nonfloor(toy.4, room_floor_dining_room.0)\nonfloor(toy.5, room_floor_dining_room.0)\nonfloor(toy.6, room_floor_dining_room.0)\nonfloor(toy.7, room_floor_dining_room.0)\nonfloor(carton.0, room_floor_living_room.0)\nontop(carton.1, breakfast_table.2)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(plaything_n_01, exists(carton_n_02, inside(plaything_n_01, carton_n_02)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(carton.0)\", \"ontop(carton.0, breakfast_table.2)\", \"holds_rh(carton.1)\", \"onfloor(carton.1, room_floor_living_room.0)\", \"holds_rh(toy.0)\", \"inside(toy.0, carton.0)\", \"holds_rh(toy.1)\", \"inside(toy.1, carton.0)\", \"holds_rh(toy.2)\", \"inside(toy.2, carton.0)\", \"holds_rh(toy.3)\", \"inside(toy.3, carton.0)\", \"holds_rh(toy.4)\", \"inside(toy.4, carton.1)\", \"holds_rh(toy.5)\", \"inside(toy.5, carton.1)\", \"holds_rh(toy.6)\", \"inside(toy.6, carton.1)\", \"holds_rh(toy.7)\", \"inside(toy.7, carton.1)\"]}\n```"
    },
    "putting_dishes_away_after_cleaning": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: putting_dishes_away_after_cleaning\n## Relevant objects in this scene\n{'name': 'plate.0', 'category': 'plate_n_04'}\n{'name': 'plate.1', 'category': 'plate_n_04'}\n{'name': 'plate.2', 'category': 'plate_n_04'}\n{'name': 'plate.3', 'category': 'plate_n_04'}\n{'name': 'plate.4', 'category': 'plate_n_04'}\n{'name': 'plate.5', 'category': 'plate_n_04'}\n{'name': 'plate.6', 'category': 'plate_n_04'}\n{'name': 'plate.7', 'category': 'plate_n_04'}\n{'name': 'countertop.81', 'category': 'countertop_n_01'}\n{'name': 'countertop.79', 'category': 'countertop_n_01'}\n{'name': 'top_cabinet.62', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(plate.0, countertop.81)\nontop(plate.1, countertop.81)\nontop(plate.2, countertop.81)\nontop(plate.3, countertop.81)\nontop(plate.4, countertop.79)\nontop(plate.5, countertop.79)\nontop(plate.6, countertop.79)\nontop(plate.7, countertop.79)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(cabinet_n_01, forall(plate_n_04, inside(plate_n_04, top_cabinet.62)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(top_cabinet.62)\", \"holds_rh(plate.0) and inside(plate.0, top_cabinet.62)\", \"holds_rh(plate.1) and inside(plate.1, top_cabinet.62)\", \"holds_rh(plate.2) and inside(plate.2, top_cabinet.62)\", \"holds_rh(plate.3) and inside(plate.3, top_cabinet.62)\", \"holds_rh(plate.4) and inside(plate.4, top_cabinet.62)\", \"holds_rh(plate.5) and inside(plate.5, top_cabinet.62)\", \"holds_rh(plate.6) and inside(plate.6, top_cabinet.62)\", \"holds_rh(plate.7) and inside(plate.7, top_cabinet.62)\", \"not open(top_cabinet.62)\"]}"
    },
    "putting_leftovers_away": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: putting_leftovers_away\n## Relevant objects in this scene\n{'name': 'pasta.0', 'category': 'pasta_n_02'}\n{'name': 'pasta.1', 'category': 'pasta_n_02'}\n{'name': 'pasta.2', 'category': 'pasta_n_02'}\n{'name': 'pasta.3', 'category': 'pasta_n_02'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'spaghetti_sauce.0', 'category': 'sauce_n_01'}\n{'name': 'mayonnaise.0', 'category': 'sauce_n_01'}\n{'name': 'spaghetti_sauce.1', 'category': 'sauce_n_01'}\n{'name': 'spaghetti_sauce.2', 'category': 'sauce_n_01'}\n{'name': 'fridge.61', 'category': 'electric_refrigerator_n_01'}\n{'name': 'countertop.79', 'category': 'countertop_n_01'}\n\n## Initial States\nontop(pasta.0, countertop.79)\nontop(pasta.1, countertop.79)\nontop(pasta.2, countertop.79)\nontop(pasta.3, countertop.79)\nontop(spaghetti_sauce.0, countertop.79)\nontop(mayonnaise.0, countertop.79)\nontop(spaghetti_sauce.1, countertop.79)\nontop(spaghetti_sauce.2, countertop.79)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(pasta_n_02, inside(pasta_n_02, fridge.61))\nforall(sauce_n_01, inside(sauce_n_01, fridge.61))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n    \"output\": [\n        \"open(fridge.61)\",\n        \"holds_rh(pasta.0)\",\n        \"inside(pasta.0, fridge.61)\",\n        \"holds_rh(pasta.1)\",\n        \"inside(pasta.1, fridge.61)\",\n        \"holds_rh(pasta.2)\",\n        \"inside(pasta.2, fridge.61)\",\n        \"holds_rh(pasta.3)\",\n        \"inside(pasta.3, fridge.61)\",\n        \"holds_rh(spaghetti_sauce.0)\",\n        \"inside(spaghetti_sauce.0, fridge.61)\",\n        \"holds_rh(mayonnaise.0)\",\n        \"inside(mayonnaise.0, fridge.61)\",\n        \"holds_rh(spaghetti_sauce.1)\",\n        \"inside(spaghetti_sauce.1, fridge.61)\",\n        \"holds_rh(spaghetti_sauce.2)\",\n        \"inside(spaghetti_sauce.2, fridge.61)\",\n        \"not open(fridge.61)\"\n    ]\n}"
    },
    "putting_up_Christmas_decorations_inside": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: putting_up_Christmas_decorations_inside\n## Relevant objects in this scene\n{'name': 'christmas_tree_decorated.112', 'category': 'christmas_tree_n_05'}\n{'name': 'wreath.113', 'category': 'wreath_n_01'}\n{'name': 'bow.114', 'category': 'bow_n_08'}\n{'name': 'bow.115', 'category': 'bow_n_08'}\n{'name': 'bow.116', 'category': 'bow_n_08'}\n{'name': 'candle.117', 'category': 'candle_n_01'}\n{'name': 'candle.118', 'category': 'candle_n_01'}\n{'name': 'wrapped_gift.119', 'category': 'wrapping_n_01'}\n{'name': 'wrapped_gift.120', 'category': 'wrapping_n_01'}\n{'name': 'wrapped_gift.121', 'category': 'wrapping_n_01'}\n{'name': 'carton.122', 'category': 'carton_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'breakfast_table.19', 'category': 'table_n_02'}\n{'name': 'sofa.25', 'category': 'sofa_n_01'}\n\n## Initial States\nonfloor(christmas_tree_decorated.112, room_floor_living_room.0)\nonfloor(carton.122, room_floor_living_room.0)\ninside(wreath.113, carton.122)\ninside(bow.114, carton.122)\ninside(bow.115, carton.122)\ninside(bow.116, carton.122)\ninside(candle.117, carton.122)\ninside(candle.118, carton.122)\nonfloor(wrapped_gift.119, room_floor_living_room.0)\nonfloor(wrapped_gift.120, room_floor_living_room.0)\nonfloor(wrapped_gift.121, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(wrapping_n_01, (nextto(wrapping_n_01, christmas_tree_decorated.112) or under(wrapping_n_01, christmas_tree_decorated.112)))\nforall(candle_n_01, ontop(candle_n_01, breakfast_table.19))\nforn(1, bow_n_08, ontop(bow_n_08, breakfast_table.19))\nforn(2, bow_n_08, ontop(bow_n_08, sofa.25))\nontop(wreath.113, breakfast_table.19)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\n  \"output\": [\n    \"open(carton.122)\",\n    \"holds_rh(wreath.113)\",\n    \"ontop(wreath.113, breakfast_table.19)\",\n    \"holds_rh(bow.114)\",\n    \"ontop(bow.114, breakfast_table.19)\",\n    \"holds_rh(bow.115)\",\n    \"ontop(bow.115, sofa.25)\",\n    \"holds_rh(bow.116)\",\n    \"ontop(bow.116, sofa.25)\",\n    \"holds_rh(candle.117)\",\n    \"ontop(candle.117, breakfast_table.19)\",\n    \"holds_rh(candle.118)\",\n    \"ontop(candle.118, breakfast_table.19)\",\n    \"nextto(wrapped_gift.119, christmas_tree_decorated.112)\",\n    \"nextto(wrapped_gift.120, christmas_tree_decorated.112)\",\n    \"under(wrapped_gift.121, christmas_tree_decorated.112)\"\n  ]\n}\n```"
    },
    "re-shelving_library_books": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: re-shelving_library_books\n## Relevant objects in this scene\n{'name': 'hardback.0', 'category': 'book_n_02'}\n{'name': 'hardback.1', 'category': 'book_n_02'}\n{'name': 'hardback.2', 'category': 'book_n_02'}\n{'name': 'notebook.0', 'category': 'book_n_02'}\n{'name': 'hardback.3', 'category': 'book_n_02'}\n{'name': 'notebook.1', 'category': 'book_n_02'}\n{'name': 'notebook.2', 'category': 'book_n_02'}\n{'name': 'notebook.3', 'category': 'book_n_02'}\n{'name': 'breakfast_table.9', 'category': 'table_n_02'}\n{'name': 'shelf.19', 'category': 'shelf_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(hardback.0, breakfast_table.9)\nontop(hardback.1, breakfast_table.9)\nontop(hardback.2, breakfast_table.9)\nontop(notebook.0, breakfast_table.9)\nontop(hardback.3, breakfast_table.9)\nontop(notebook.1, breakfast_table.9)\nontop(notebook.2, breakfast_table.9)\nontop(notebook.3, breakfast_table.9)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nontop(hardback.0, shelf.19)\nontop(hardback.1, shelf.19)\nontop(hardback.2, shelf.19)\nontop(notebook.0, shelf.19)\nontop(hardback.3, breakfast_table.9)\nontop(notebook.1, breakfast_table.9)\nontop(notebook.2, breakfast_table.9)\nontop(notebook.3, breakfast_table.9)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(hardback.0)\", \"ontop(hardback.0, shelf.19)\", \"holds_rh(hardback.1)\", \"ontop(hardback.1, shelf.19)\", \"holds_rh(hardback.2)\", \"ontop(hardback.2, shelf.19)\", \"holds_rh(notebook.0)\", \"ontop(notebook.0, shelf.19)\"]}"
    },
    "rearranging_furniture": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: rearranging_furniture\n## Relevant objects in this scene\n{'name': 'table_lamp.0', 'category': 'lamp_n_02'}\n{'name': 'floor_lamp.1', 'category': 'lamp_n_02'}\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'chaise_longue.0', 'category': 'seat_n_03'}\n{'name': 'chaise_longue.1', 'category': 'seat_n_03'}\n{'name': 'bed.11', 'category': 'bed_n_01'}\n{'name': 'window.27', 'category': 'window_n_01'}\n{'name': 'door.29', 'category': 'door_n_01'}\n\n## Initial States\nonfloor(table_lamp.0, room_floor_bedroom.0)\nonfloor(floor_lamp.1, room_floor_bedroom.0)\nonfloor(chaise_longue.0, room_floor_bedroom.0)\nontop(chaise_longue.1, bed.11)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nnextto(table_lamp.0, door.29)\nnextto(floor_lamp.1, window.27)\ntouching(chaise_longue.0, bed.11)\nnextto(chaise_longue.1, window.27)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(table_lamp.0)\", \"nextto(table_lamp.0, door.29)\", \"holds_rh(floor_lamp.1)\", \"nextto(floor_lamp.1, window.27)\", \"holds_rh(chaise_longue.1)\", \"nextto(chaise_longue.1, window.27)\", \"holds_rh(chaise_longue.0)\", \"touching(chaise_longue.0, bed.11)\"]}\n```"
    },
    "serving_a_meal": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: serving_a_meal\n## Relevant objects in this scene\n{'name': 'chicken.0', 'category': 'chicken_n_01'}\n{'name': 'chicken.1', 'category': 'chicken_n_01'}\n{'name': 'table_knife.0', 'category': 'knife_n_01'}\n{'name': 'carving_knife.0', 'category': 'knife_n_01'}\n{'name': 'toasting_fork.0', 'category': 'fork_n_01'}\n{'name': 'tablefork.0', 'category': 'fork_n_01'}\n{'name': 'spoon.0', 'category': 'spoon_n_01'}\n{'name': 'spoon.1', 'category': 'spoon_n_01'}\n{'name': 'plate.0', 'category': 'plate_n_04'}\n{'name': 'plate.1', 'category': 'plate_n_04'}\n{'name': 'soup.0', 'category': 'soup_n_01'}\n{'name': 'soup.1', 'category': 'soup_n_01'}\n{'name': 'breakfast_table.20', 'category': 'table_n_02'}\n{'name': 'muffin.0', 'category': 'bread_n_01'}\n{'name': 'bagel.0', 'category': 'bread_n_01'}\n{'name': 'fridge.57', 'category': 'electric_refrigerator_n_01'}\n{'name': 'salad.0', 'category': 'salad_n_01'}\n{'name': 'salad.1', 'category': 'salad_n_01'}\n{'name': 'water.0', 'category': 'water_n_06'}\n{'name': 'water.1', 'category': 'water_n_06'}\n{'name': 'cookie.0', 'category': 'cake_n_03'}\n{'name': 'cupcake.0', 'category': 'cake_n_03'}\n{'name': 'stove.59', 'category': 'stove_n_01'}\n{'name': 'bottom_cabinet.49', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet.50', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ncooked(chicken.0)\ncooked(chicken.1)\ninside(table_knife.0, bottom_cabinet.49)\ninside(carving_knife.0, bottom_cabinet.49)\ninside(toasting_fork.0, bottom_cabinet.49)\ninside(tablefork.0, bottom_cabinet.49)\ninside(spoon.0, bottom_cabinet.49)\ninside(spoon.1, bottom_cabinet.49)\ninside(plate.0, bottom_cabinet.50)\ninside(plate.1, bottom_cabinet.49)\nontop(soup.0, breakfast_table.20)\nontop(soup.1, breakfast_table.20)\ninside(bagel.0, fridge.57)\ninside(muffin.0, fridge.57)\ninside(salad.0, fridge.57)\ninside(salad.1, fridge.57)\ninside(chicken.0, fridge.57)\ninside(chicken.1, fridge.57)\ninside(water.0, fridge.57)\ninside(water.1, fridge.57)\ninside(cookie.0, fridge.57)\ninside(cupcake.0, fridge.57)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(plate_n_04, ontop(plate_n_04, breakfast_table.20))\nforall(knife_n_01, ontop(knife_n_01, breakfast_table.20))\nforall(fork_n_01, ontop(fork_n_01, breakfast_table.20))\nforpairs(spoon_n_01, soup_n_01, nextto(spoon_n_01, soup_n_01))\nforall(water_n_06, ontop(water_n_06, breakfast_table.20))\nforpairs(chicken_n_01, plate_n_04, ontop(chicken_n_01, plate_n_04))\nforpairs(salad_n_01, plate_n_04, nextto(salad_n_01, plate_n_04))\nforpairs(bread_n_01, plate_n_04, nextto(bread_n_01, plate_n_04))\nforpairs(cake_n_03, plate_n_04, nextto(cake_n_03, plate_n_04))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\n    \"open(bottom_cabinet.49) and open(bottom_cabinet.50)\",\n    \"ontop(plate.0, breakfast_table.20) and ontop(plate.1, breakfast_table.20)\",\n    \"ontop(table_knife.0, breakfast_table.20) and ontop(carving_knife.0, breakfast_table.20) and ontop(toasting_fork.0, breakfast_table.20) and ontop(tablefork.0, breakfast_table.20) and ontop(spoon.0, breakfast_table.20) and ontop(spoon.1, breakfast_table.20)\",\n    \"nextto(spoon.0, soup.0) and nextto(spoon.1, soup.1)\",\n    \"ontop(water.0, breakfast_table.20) and ontop(water.1, breakfast_table.20)\",\n    \"ontop(chicken.0, plate.0) and ontop(chicken.1, plate.1)\",\n    \"nextto(salad.0, plate.0) and nextto(salad.1, plate.1)\",\n    \"nextto(bagel.0, plate.0) and nextto(muffin.0, plate.1)\",\n    \"nextto(cookie.0, plate.0) and nextto(cupcake.0, plate.1)\"\n]}"
    },
    "serving_hors_d_oeuvres": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: serving_hors_d_oeuvres\n## Relevant objects in this scene\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'salad.143', 'category': 'salad_n_01'}\n{'name': 'salad.144', 'category': 'salad_n_01'}\n{'name': 'salad.145', 'category': 'salad_n_01'}\n{'name': 'salad.146', 'category': 'salad_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'tray.147', 'category': 'tray_n_01'}\n{'name': 'parsley.148', 'category': 'parsley_n_02'}\n{'name': 'parsley.149', 'category': 'parsley_n_02'}\n{'name': 'parsley.150', 'category': 'parsley_n_02'}\n{'name': 'parsley.151', 'category': 'parsley_n_02'}\n{'name': 'pretzel.152', 'category': 'cracker_n_01'}\n{'name': 'pretzel.153', 'category': 'cracker_n_01'}\n{'name': 'pretzel.154', 'category': 'cracker_n_01'}\n{'name': 'pretzel.155', 'category': 'cracker_n_01'}\n{'name': 'breakfast_table.1', 'category': 'table_n_02'}\n{'name': 'cheese.156', 'category': 'cheese_n_01'}\n{'name': 'cheese.157', 'category': 'cheese_n_01'}\n{'name': 'cheese.158', 'category': 'cheese_n_01'}\n{'name': 'cheese.159', 'category': 'cheese_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(salad.143, fridge.97)\ninside(salad.144, fridge.97)\ninside(salad.145, fridge.97)\ninside(salad.146, fridge.97)\ninside(parsley.148, fridge.97)\ninside(parsley.149, fridge.97)\ninside(parsley.150, fridge.97)\ninside(parsley.151, fridge.97)\nonfloor(tray.147, room_floor_dining_room.0)\nontop(pretzel.152, breakfast_table.1)\nontop(pretzel.153, breakfast_table.1)\nontop(pretzel.154, breakfast_table.1)\nontop(pretzel.155, breakfast_table.1)\ninside(cheese.156, fridge.97)\ninside(cheese.157, fridge.97)\ninside(cheese.158, fridge.97)\ninside(cheese.159, fridge.97)\nonfloor(agent_n_01.1, room_floor_dining_room.0)\n\n## Goal States\nontop(tray.147, breakfast_table.1)\nforall(cracker_n_01, ontop(cracker_n_01, breakfast_table.1))\nforpairs(salad_n_01, cracker_n_01, nextto(salad_n_01, cracker_n_01))\nforpairs(cheese_n_01, parsley_n_02, ontop(parsley_n_02, cheese_n_01))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"ontop(tray.147, breakfast_table.1)\", \"ontop(pretzel.152, breakfast_table.1) and ontop(pretzel.153, breakfast_table.1) and ontop(pretzel.154, breakfast_table.1) and ontop(pretzel.155, breakfast_table.1)\", \"ontop(salad.143, breakfast_table.1)\", \"nextto(salad.143, pretzel.152) and nextto(salad.143, pretzel.153) and nextto(salad.143, pretzel.154) and nextto(salad.143, pretzel.155)\", \"ontop(salad.144, breakfast_table.1)\", \"nextto(salad.144, pretzel.152) and nextto(salad.144, pretzel.153) and nextto(salad.144, pretzel.154) and nextto(salad.144, pretzel.155)\", \"ontop(salad.145, breakfast_table.1)\", \"nextto(salad.145, pretzel.152) and nextto(salad.145, pretzel.153) and nextto(salad.145, pretzel.154) and nextto(salad.145, pretzel.155)\", \"ontop(salad.146, breakfast_table.1)\", \"nextto(salad.146, pretzel.152) and nextto(salad.146, pretzel.153) and nextto(salad.146, pretzel.154) and nextto(salad.146, pretzel.155)\", \"ontop(cheese.156, breakfast_table.1)\", \"ontop(parsley.148, cheese.156)\", \"ontop(cheese.157, breakfast_table.1)\", \"ontop(parsley.149, cheese.157)\", \"ontop(cheese.158, breakfast_table.1)\", \"ontop(parsley.150, cheese.158)\", \"ontop(cheese.159, breakfast_table.1)\", \"ontop(parsley.151, cheese.159)\"]}"
    },
    "setting_mousetraps": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: setting_mousetraps\n## Relevant objects in this scene\n{'name': 'mousetrap.100', 'category': 'mousetrap_n_01'}\n{'name': 'mousetrap.101', 'category': 'mousetrap_n_01'}\n{'name': 'mousetrap.102', 'category': 'mousetrap_n_01'}\n{'name': 'mousetrap.103', 'category': 'mousetrap_n_01'}\n{'name': 'sink.73', 'category': 'sink_n_01'}\n{'name': 'room_floor_corridor.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'toilet.64', 'category': 'toilet_n_02'}\n{'name': 'bed.43', 'category': 'bed_n_01'}\n\n## Initial States\nontop(mousetrap.100, bed.43)\nontop(mousetrap.101, bed.43)\nontop(mousetrap.102, bed.43)\nontop(mousetrap.103, bed.43)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nonfloor(mousetrap.100, room_floor_corridor.0)\nonfloor(mousetrap.101, room_floor_corridor.0)\nnextto(mousetrap.102, toilet.64)\nnextto(mousetrap.103, toilet.64)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\n    \"output\": [\n        \"holds_rh(mousetrap.100)\",\n        \"onfloor(mousetrap.100, room_floor_corridor.0)\",\n        \"holds_rh(mousetrap.101)\",\n        \"onfloor(mousetrap.101, room_floor_corridor.0)\",\n        \"holds_rh(mousetrap.102)\",\n        \"nextto(mousetrap.102, toilet.64)\",\n        \"holds_rh(mousetrap.103)\",\n        \"nextto(mousetrap.103, toilet.64)\"\n    ]\n}\n```"
    },
    "setting_up_candles": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: setting_up_candles\n## Relevant objects in this scene\n{'name': 'candle.0', 'category': 'candle_n_01'}\n{'name': 'candle.1', 'category': 'candle_n_01'}\n{'name': 'candle.2', 'category': 'candle_n_01'}\n{'name': 'candle.3', 'category': 'candle_n_01'}\n{'name': 'candle.4', 'category': 'candle_n_01'}\n{'name': 'candle.5', 'category': 'candle_n_01'}\n{'name': 'coffee_table.33', 'category': 'table_n_02'}\n{'name': 'breakfast_table.1', 'category': 'table_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'carton.1', 'category': 'carton_n_02'}\n\n## Initial States\nonfloor(carton.0, room_floor_living_room.0)\nonfloor(carton.1, room_floor_living_room.0)\ninside(candle.0, carton.0)\ninside(candle.1, carton.0)\ninside(candle.2, carton.0)\ninside(candle.3, carton.1)\ninside(candle.4, carton.1)\ninside(candle.5, carton.1)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforn(3, candle_n_01, ontop(candle_n_01, coffee_table.33))\nforn(3, candle_n_01, ontop(candle_n_01, breakfast_table.1))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"open(carton.0) and open(carton.1)\", \"holds_rh(candle.0) and ontop(candle.0, coffee_table.33)\", \"holds_rh(candle.1) and ontop(candle.1, coffee_table.33)\", \"holds_rh(candle.2) and ontop(candle.2, coffee_table.33)\", \"holds_rh(candle.3) and ontop(candle.3, breakfast_table.1)\", \"holds_rh(candle.4) and ontop(candle.4, breakfast_table.1)\", \"holds_rh(candle.5) and ontop(candle.5, breakfast_table.1)\"]}\n```"
    },
    "sorting_books": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: sorting_books\n## Relevant objects in this scene\n{'name': 'hardback.78', 'category': 'hardback_n_01'}\n{'name': 'hardback.79', 'category': 'hardback_n_01'}\n{'name': 'coffee_table.3', 'category': 'table_n_02'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'shelf.15', 'category': 'shelf_n_01'}\n{'name': 'notebook.80', 'category': 'book_n_02'}\n{'name': 'hardback.81', 'category': 'book_n_02'}\n\n## Initial States\nontop(hardback.78, coffee_table.3)\nonfloor(hardback.79, room_floor_living_room.0)\nonfloor(notebook.80, room_floor_living_room.0)\nontop(hardback.81, coffee_table.3)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(hardback_n_01, ontop(hardback_n_01, shelf.15))\nforall(book_n_02, ontop(book_n_02, shelf.15))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n  \"output\": [\n    \"holds_rh(hardback.78)\",\n    \"ontop(hardback.78, shelf.15)\",\n    \"holds_rh(hardback.79)\",\n    \"ontop(hardback.79, shelf.15)\",\n    \"holds_rh(notebook.80)\",\n    \"ontop(notebook.80, shelf.15)\",\n    \"holds_rh(hardback.81)\",\n    \"ontop(hardback.81, shelf.15)\"\n  ]\n}"
    },
    "sorting_groceries": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: sorting_groceries\n## Relevant objects in this scene\n{'name': 'pretzel.0', 'category': 'bread_n_01'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'flour.0', 'category': 'flour_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'milk.0', 'category': 'milk_n_01'}\n{'name': 'straight_chair.45', 'category': 'chair_n_01'}\n{'name': 'prosciutto.0', 'category': 'meat_n_01'}\n{'name': 'breakfast_table.44', 'category': 'table_n_02'}\n{'name': 'cheese.0', 'category': 'cheese_n_01'}\n{'name': 'yogurt.0', 'category': 'yogurt_n_01'}\n{'name': 'soup.0', 'category': 'soup_n_01'}\n{'name': 'carrot.0', 'category': 'carrot_n_03'}\n{'name': 'carrot.1', 'category': 'carrot_n_03'}\n{'name': 'carrot.2', 'category': 'carrot_n_03'}\n{'name': 'broccoli.0', 'category': 'broccoli_n_02'}\n{'name': 'apple.0', 'category': 'apple_n_01'}\n{'name': 'apple.1', 'category': 'apple_n_01'}\n{'name': 'orange.0', 'category': 'orange_n_01'}\n{'name': 'orange.1', 'category': 'orange_n_01'}\n{'name': 'orange.2', 'category': 'orange_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n\n## Initial States\nontop(pretzel.0, countertop.84)\nonfloor(flour.0, room_floor_kitchen.0)\nontop(milk.0, straight_chair.45)\nontop(prosciutto.0, breakfast_table.44)\nontop(cheese.0, breakfast_table.44)\nontop(yogurt.0, breakfast_table.44)\nontop(soup.0, breakfast_table.44)\nontop(carrot.0, countertop.84)\nontop(carrot.1, countertop.84)\nontop(carrot.2, countertop.84)\nontop(broccoli.0, countertop.84)\nontop(apple.0, countertop.84)\nontop(apple.1, countertop.84)\nontop(orange.0, breakfast_table.44)\nontop(orange.1, breakfast_table.44)\nontop(orange.2, breakfast_table.44)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\ninside(pretzel.0, bottom_cabinet_no_top.80)\ninside(flour.0, bottom_cabinet_no_top.80)\ninside(milk.0, fridge.97) and inside(prosciutto.0, fridge.97) and inside(cheese.0, fridge.97) and inside(yogurt.0, fridge.97) and inside(soup.0, fridge.97)\nforall(carrot_n_03, (inside(carrot_n_03, fridge.97) and (nextto(carrot_n_03, carrot.0) or nextto(carrot_n_03, carrot.1) or nextto(carrot_n_03, carrot.2))))\ninside(broccoli.0, fridge.97)\nforall(apple_n_01, (inside(apple_n_01, fridge.97) and (nextto(apple_n_01, apple.0) or nextto(apple_n_01, apple.1))))\nforall(orange_n_01, (ontop(orange_n_01, breakfast_table.44) and (nextto(orange_n_01, orange.0) or nextto(orange_n_01, orange.1) or nextto(orange_n_01, orange.2))))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\n  \"output\": [\n    \"holds_rh(pretzel.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(pretzel.0, bottom_cabinet_no_top.80)\",\n    \"holds_rh(flour.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(flour.0, bottom_cabinet_no_top.80)\",\n    \"holds_rh(milk.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(milk.0, fridge.97)\",\n    \"holds_rh(prosciutto.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(prosciutto.0, fridge.97)\",\n    \"holds_rh(cheese.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(cheese.0, fridge.97)\",\n    \"holds_rh(yogurt.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(yogurt.0, fridge.97)\",\n    \"holds_rh(soup.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(soup.0, fridge.97)\",\n    \"holds_rh(carrot.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(carrot.0, fridge.97)\",\n    \"holds_rh(carrot.1) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(carrot.1, fridge.97) and nextto(carrot.1, carrot.0)\",\n    \"holds_rh(carrot.2) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(carrot.2, fridge.97) and nextto(carrot.2, carrot.1)\",\n    \"holds_rh(broccoli.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(broccoli.0, fridge.97)\",\n    \"holds_rh(apple.0) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(apple.0, fridge.97)\",\n    \"holds_rh(apple.1) and onfloor(agent_n_01.1, room_floor_kitchen.0)\",\n    \"inside(apple.1, fridge.97) and nextto(apple.1, apple.0)\",\n    \"ontop(orange.0, breakfast_table.44) and nextto(orange.0, orange.1)\",\n    \"ontop(orange.1, breakfast_table.44) and nextto(orange.1, orange.2)\",\n    \"ontop(orange.2, breakfast_table.44) and nextto(orange.2, orange.0)\"\n  ]\n}\n```"
    },
    "sorting_mail": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: sorting_mail\n## Relevant objects in this scene\n{'name': 'envelope.143', 'category': 'envelope_n_01'}\n{'name': 'envelope.144', 'category': 'envelope_n_01'}\n{'name': 'envelope.145', 'category': 'envelope_n_01'}\n{'name': 'envelope.146', 'category': 'envelope_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'sofa.39', 'category': 'sofa_n_01'}\n{'name': 'newspaper.147', 'category': 'newspaper_n_03'}\n{'name': 'newspaper.148', 'category': 'newspaper_n_03'}\n{'name': 'newspaper.149', 'category': 'newspaper_n_03'}\n{'name': 'newspaper.150', 'category': 'newspaper_n_03'}\n\n## Initial States\nonfloor(envelope.143, room_floor_living_room.0)\nonfloor(envelope.144, room_floor_living_room.0)\nonfloor(envelope.145, room_floor_living_room.0)\nonfloor(envelope.146, room_floor_living_room.0)\nonfloor(newspaper.147, room_floor_living_room.0)\nonfloor(newspaper.148, room_floor_living_room.0)\nonfloor(newspaper.149, room_floor_living_room.0)\nonfloor(newspaper.150, room_floor_living_room.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nforall(envelope_n_01, (touching(envelope_n_01, envelope.143) or touching(envelope_n_01, envelope.144) or touching(envelope_n_01, envelope.145) or touching(envelope_n_01, envelope.146)))\nforall(newspaper_n_03, (touching(newspaper_n_03, newspaper.147) or touching(newspaper_n_03, newspaper.148) or touching(newspaper_n_03, newspaper.149) or touching(newspaper_n_03, newspaper.150)))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"holds_rh(envelope.143)\", \"ontop(envelope.143, sofa.39)\", \"holds_rh(envelope.144)\", \"ontop(envelope.144, sofa.39) and touching(envelope.144, envelope.143)\", \"holds_rh(envelope.145)\", \"ontop(envelope.145, sofa.39) and touching(envelope.145, envelope.144)\", \"holds_rh(envelope.146)\", \"ontop(envelope.146, sofa.39) and touching(envelope.146, envelope.145)\", \"holds_rh(newspaper.147)\", \"ontop(newspaper.147, sofa.39)\", \"holds_rh(newspaper.148)\", \"ontop(newspaper.148, sofa.39) and touching(newspaper.148, newspaper.147)\", \"holds_rh(newspaper.149)\", \"ontop(newspaper.149, sofa.39) and touching(newspaper.149, newspaper.148)\", \"holds_rh(newspaper.150)\", \"ontop(newspaper.150, sofa.39) and touching(newspaper.150, newspaper.149)\"]}\n```"
    },
    "storing_food": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: storing_food\n## Relevant objects in this scene\n{'name': 'oatmeal.0', 'category': 'oatmeal_n_01'}\n{'name': 'oatmeal.1', 'category': 'oatmeal_n_01'}\n{'name': 'countertop.26', 'category': 'countertop_n_01'}\n{'name': 'chip.0', 'category': 'chip_n_04'}\n{'name': 'chip.1', 'category': 'chip_n_04'}\n{'name': 'olive_oil.0', 'category': 'vegetable_oil_n_01'}\n{'name': 'olive_oil.1', 'category': 'vegetable_oil_n_01'}\n{'name': 'sugar_jar.0', 'category': 'sugar_n_01'}\n{'name': 'sugar_jar.1', 'category': 'sugar_n_01'}\n{'name': 'bottom_cabinet.41', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(oatmeal.0, countertop.26)\nontop(oatmeal.1, countertop.26)\nontop(chip.0, countertop.26)\nontop(chip.1, countertop.26)\nontop(olive_oil.0, countertop.26)\nontop(olive_oil.1, countertop.26)\nontop(sugar_jar.0, countertop.26)\nontop(sugar_jar.1, countertop.26)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\ninside(oatmeal.0, bottom_cabinet.41)\ninside(oatmeal.1, bottom_cabinet.41)\ninside(chip.0, bottom_cabinet.41)\ninside(chip.1, bottom_cabinet.41)\ninside(olive_oil.0, bottom_cabinet.41)\ninside(olive_oil.1, bottom_cabinet.41)\ninside(sugar_jar.0, bottom_cabinet.41)\ninside(sugar_jar.1, bottom_cabinet.41)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"open(bottom_cabinet.41)\", \"holds_rh(oatmeal.0)\", \"inside(oatmeal.0, bottom_cabinet.41)\", \"holds_rh(oatmeal.1)\", \"inside(oatmeal.1, bottom_cabinet.41)\", \"holds_rh(chip.0)\", \"inside(chip.0, bottom_cabinet.41)\", \"holds_rh(chip.1)\", \"inside(chip.1, bottom_cabinet.41)\", \"holds_rh(olive_oil.0)\", \"inside(olive_oil.0, bottom_cabinet.41)\", \"holds_rh(olive_oil.1)\", \"inside(olive_oil.1, bottom_cabinet.41)\", \"holds_rh(sugar_jar.0)\", \"inside(sugar_jar.0, bottom_cabinet.41)\", \"holds_rh(sugar_jar.1)\", \"inside(sugar_jar.1, bottom_cabinet.41)\", \"not open(bottom_cabinet.41)\"]}"
    },
    "storing_the_groceries": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: storing_the_groceries\n## Relevant objects in this scene\n{'name': 'cereal.0', 'category': 'cereal_n_03'}\n{'name': 'cereal.1', 'category': 'cereal_n_03'}\n{'name': 'countertop.56', 'category': 'countertop_n_01'}\n{'name': 'lettuce.0', 'category': 'lettuce_n_03'}\n{'name': 'lettuce.1', 'category': 'lettuce_n_03'}\n{'name': 'broccoli.0', 'category': 'broccoli_n_02'}\n{'name': 'broccoli.1', 'category': 'broccoli_n_02'}\n{'name': 'raspberry.0', 'category': 'raspberry_n_02'}\n{'name': 'raspberry.1', 'category': 'raspberry_n_02'}\n{'name': 'pork.0', 'category': 'pork_n_01'}\n{'name': 'pork.1', 'category': 'pork_n_01'}\n{'name': 'fridge.57', 'category': 'electric_refrigerator_n_01'}\n{'name': 'bottom_cabinet_no_top.54', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(cereal.0, countertop.56)\nontop(cereal.1, countertop.56)\nontop(lettuce.0, countertop.56)\nontop(lettuce.1, countertop.56)\nontop(broccoli.0, countertop.56)\nontop(broccoli.1, countertop.56)\nontop(raspberry.0, countertop.56)\nontop(raspberry.1, countertop.56)\nontop(pork.0, countertop.56)\nontop(pork.1, countertop.56)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\ninside(cereal.0, bottom_cabinet_no_top.54)\ninside(cereal.1, bottom_cabinet_no_top.54)\nnextto(cereal.0, cereal.1)\ninside(lettuce.0, fridge.57)\ninside(lettuce.1, fridge.57)\nnextto(lettuce.0, lettuce.1)\ninside(broccoli.0, fridge.57)\ninside(broccoli.1, fridge.57)\nnextto(broccoli.0, broccoli.1)\ninside(raspberry.0, fridge.57)\ninside(raspberry.1, fridge.57)\nnextto(raspberry.0, raspberry.1)\ninside(pork.0, fridge.57)\ninside(pork.1, fridge.57)\nnextto(pork.0, pork.1)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n  \"output\": [\n    \"holds_rh(cereal.0)\",\n    \"inside(cereal.0, bottom_cabinet_no_top.54)\",\n    \"holds_rh(cereal.1)\",\n    \"inside(cereal.1, bottom_cabinet_no_top.54)\",\n    \"nextto(cereal.0, cereal.1)\",\n    \"holds_rh(lettuce.0)\",\n    \"inside(lettuce.0, fridge.57)\",\n    \"holds_rh(lettuce.1)\",\n    \"inside(lettuce.1, fridge.57)\",\n    \"nextto(lettuce.0, lettuce.1)\",\n    \"holds_rh(broccoli.0)\",\n    \"inside(broccoli.0, fridge.57)\",\n    \"holds_rh(broccoli.1)\",\n    \"inside(broccoli.1, fridge.57)\",\n    \"nextto(broccoli.0, broccoli.1)\",\n    \"holds_rh(raspberry.0)\",\n    \"inside(raspberry.0, fridge.57)\",\n    \"holds_rh(raspberry.1)\",\n    \"inside(raspberry.1, fridge.57)\",\n    \"nextto(raspberry.0, raspberry.1)\",\n    \"holds_rh(pork.0)\",\n    \"inside(pork.0, fridge.57)\",\n    \"holds_rh(pork.1)\",\n    \"inside(pork.1, fridge.57)\",\n    \"nextto(pork.0, pork.1)\"\n  ]\n}"
    },
    "thawing_frozen_food": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: thawing_frozen_food\n## Relevant objects in this scene\n{'name': 'container_date.0', 'category': 'date_n_08'}\n{'name': 'fridge.20', 'category': 'electric_refrigerator_n_01'}\n{'name': 'olive.0', 'category': 'olive_n_04'}\n{'name': 'fish.0', 'category': 'fish_n_02'}\n{'name': 'fish.1', 'category': 'fish_n_02'}\n{'name': 'fish.2', 'category': 'fish_n_02'}\n{'name': 'fish.3', 'category': 'fish_n_02'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(container_date.0, fridge.20)\ninside(olive.0, fridge.20)\ninside(fish.0, fridge.20)\ninside(fish.1, fridge.20)\ninside(fish.2, fridge.20)\ninside(fish.3, fridge.20)\nfrozen(fish.0)\nfrozen(fish.1)\nfrozen(fish.2)\nfrozen(fish.3)\nfrozen(container_date.0)\nfrozen(olive.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nnextto(container_date.0, fish.0)\nnextto(fish.0, sink.37)\nnextto(fish.1, sink.37)\nnextto(fish.2, sink.37)\nnextto(fish.3, sink.37)\nnextto(olive.0, sink.37)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"open(fridge.20)\", \"ontop(container_date.0, room_floor_kitchen.0) and ontop(olive.0, room_floor_kitchen.0) and ontop(fish.0, room_floor_kitchen.0) and ontop(fish.1, room_floor_kitchen.0) and ontop(fish.2, room_floor_kitchen.0) and ontop(fish.3, room_floor_kitchen.0)\", \"nextto(container_date.0, fish.0)\", \"nextto(fish.0, sink.37) and nextto(fish.1, sink.37) and nextto(fish.2, sink.37) and nextto(fish.3, sink.37) and nextto(olive.0, sink.37)\"]}\n```"
    },
    "throwing_away_leftovers": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: throwing_away_leftovers\n## Relevant objects in this scene\n{'name': 'plate.112', 'category': 'plate_n_04'}\n{'name': 'plate.113', 'category': 'plate_n_04'}\n{'name': 'plate.114', 'category': 'plate_n_04'}\n{'name': 'plate.115', 'category': 'plate_n_04'}\n{'name': 'hamburger.116', 'category': 'hamburger_n_01'}\n{'name': 'hamburger.117', 'category': 'hamburger_n_01'}\n{'name': 'hamburger.118', 'category': 'hamburger_n_01'}\n{'name': 'countertop.79', 'category': 'countertop_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'trash_can.119', 'category': 'ashcan_n_01'}\n\n## Initial States\nontop(plate.112, countertop.79)\nontop(hamburger.116, plate.112)\nontop(plate.113, countertop.79)\nontop(hamburger.118, plate.113)\nontop(plate.114, countertop.79)\nontop(hamburger.117, plate.114)\nontop(plate.115, countertop.79)\nonfloor(trash_can.119, room_floor_kitchen.0)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(hamburger_n_01, inside(hamburger_n_01, trash_can.119))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(hamburger.116)\", \"inside(hamburger.116, trash_can.119)\", \"holds_rh(hamburger.118)\", \"inside(hamburger.118, trash_can.119)\", \"holds_rh(hamburger.117)\", \"inside(hamburger.117, trash_can.119)\"]}"
    },
    "unpacking_suitcase": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: unpacking_suitcase\n## Relevant objects in this scene\n{'name': 'sock.0', 'category': 'sock_n_01'}\n{'name': 'sock.1', 'category': 'sock_n_01'}\n{'name': 'room_floor_living_room.0', 'category': 'floor_n_01'}\n{'name': 'carton.0', 'category': 'carton_n_02'}\n{'name': 'cologne.0', 'category': 'perfume_n_02'}\n{'name': 'toothbrush.0', 'category': 'toothbrush_n_01'}\n{'name': 'notebook.0', 'category': 'notebook_n_01'}\n{'name': 'sofa.10', 'category': 'sofa_n_01'}\n\n## Initial States\nonfloor(carton.0, room_floor_living_room.0)\ninside(sock.0, carton.0)\ninside(sock.1, carton.0)\ninside(cologne.0, carton.0)\ninside(toothbrush.0, carton.0)\ninside(notebook.0, carton.0)\nonfloor(agent_n_01.1, room_floor_living_room.0)\n\n## Goal States\nonfloor(carton.0, room_floor_living_room.0)\nforall(sock_n_01, ontop(sock_n_01, sofa.10))\nontop(cologne.0, sofa.10)\nontop(toothbrush.0, sofa.10)\nontop(notebook.0, sofa.10)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "```json\n{\"output\": [\"open(carton.0)\", \"ontop(sock.0, sofa.10) and ontop(sock.1, sofa.10)\", \"ontop(cologne.0, sofa.10)\", \"ontop(toothbrush.0, sofa.10)\", \"ontop(notebook.0, sofa.10)\"]}\n```"
    },
    "vacuuming_floors": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: vacuuming_floors\n## Relevant objects in this scene\n{'name': 'room_floor_bedroom.0', 'category': 'floor_n_01'}\n{'name': 'vacuum.0', 'category': 'vacuum_n_04'}\n{'name': 'trash_can.0', 'category': 'ashcan_n_01'}\n\n## Initial States\ndusty(room_floor_bedroom.0)\nonfloor(vacuum.0, room_floor_bedroom.0)\nonfloor(trash_can.0, room_floor_bedroom.0)\nonfloor(agent_n_01.1, room_floor_bedroom.0)\n\n## Goal States\nnot dusty(room_floor_bedroom.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(vacuum.0)\", \"toggledon(vacuum.0)\", \"not dusty(room_floor_bedroom.0)\"]}"
    },
    "washing_cars_or_other_vehicles": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: washing_cars_or_other_vehicles\n## Relevant objects in this scene\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'car.0', 'category': 'car_n_01'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'rag.0', 'category': 'rag_n_01'}\n{'name': 'sink.32', 'category': 'sink_n_01'}\n\n## Initial States\nontop(soap.0, car.0)\nonfloor(car.0, room_floor_garage.0)\nontop(bucket.0, car.0)\nontop(rag.0, car.0)\ndusty(car.0)\nstained(car.0)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nnot dusty(car.0)\nnot stained(car.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n  \"output\": [\n    \"holds_rh(rag.0)\",\n    \"soaked(rag.0)\",\n    \"holds_rh(soap.0) and holds_lh(rag.0)\",\n    \"not stained(car.0)\",\n    \"not dusty(car.0)\"\n  ]\n}"
    },
    "washing_dishes": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: washing_dishes\n## Relevant objects in this scene\n{'name': 'plate.59', 'category': 'plate_n_04'}\n{'name': 'plate.60', 'category': 'plate_n_04'}\n{'name': 'cup.61', 'category': 'cup_n_01'}\n{'name': 'sink.19', 'category': 'sink_n_01'}\n{'name': 'bowl.62', 'category': 'bowl_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'countertop.18', 'category': 'countertop_n_01'}\n{'name': 'scrub_brush.63', 'category': 'scrub_brush_n_01'}\n\n## Initial States\nontop(plate.59, countertop.18)\nontop(plate.60, countertop.18)\nontop(bowl.62, countertop.18)\nontop(cup.61, countertop.18)\ninside(scrub_brush.63, sink.19)\nstained(plate.59)\nstained(plate.60)\nstained(cup.61)\nstained(bowl.62)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(plate_n_04, (not stained(plate_n_04)))\nnot stained(cup.61)\nnot stained(bowl.62)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(plate.59)\", \"inside(plate.59, sink.19) and not holds_rh(plate.59)\", \"toggledon(sink.19)\", \"not stained(plate.59)\", \"holds_rh(plate.59) and not inside(plate.59, sink.19)\", \"ontop(plate.59, countertop.18) and not holds_rh(plate.59)\", \"holds_rh(plate.60)\", \"inside(plate.60, sink.19) and not holds_rh(plate.60)\", \"not stained(plate.60)\", \"holds_rh(plate.60) and not inside(plate.60, sink.19)\", \"ontop(plate.60, countertop.18) and not holds_rh(plate.60)\", \"holds_rh(cup.61)\", \"inside(cup.61, sink.19) and not holds_rh(cup.61)\", \"not stained(cup.61)\", \"holds_rh(cup.61) and not inside(cup.61, sink.19)\", \"ontop(cup.61, countertop.18) and not holds_rh(cup.61)\", \"holds_rh(bowl.62)\", \"inside(bowl.62, sink.19) and not holds_rh(bowl.62)\", \"not stained(bowl.62)\", \"holds_rh(bowl.62) and not inside(bowl.62, sink.19)\", \"ontop(bowl.62, countertop.18) and not holds_rh(bowl.62)\"]}"
    },
    "washing_floor": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: washing_floor\n## Relevant objects in this scene\n{'name': 'bucket.0', 'category': 'bucket_n_01'}\n{'name': 'room_floor_bathroom.0', 'category': 'floor_n_01'}\n{'name': 'soap.0', 'category': 'soap_n_01'}\n{'name': 'bath_towel.0', 'category': 'towel_n_01'}\n{'name': 'shower.32', 'category': 'shower_n_01'}\n{'name': 'toilet.47', 'category': 'toilet_n_02'}\n{'name': 'bed.33', 'category': 'bed_n_01'}\n{'name': 'sink.49', 'category': 'sink_n_01'}\n\n## Initial States\nonfloor(bucket.0, room_floor_bathroom.0)\nontop(soap.0, bath_towel.0)\nonfloor(soap.0, room_floor_bathroom.0)\nonfloor(bath_towel.0, room_floor_bathroom.0)\nnot stained(bath_towel.0)\ndusty(room_floor_bathroom.0)\nstained(room_floor_bathroom.0)\nonfloor(agent_n_01.1, room_floor_bathroom.0)\n\n## Goal States\nnot (dusty(room_floor_bathroom.0) or stained(room_floor_bathroom.0))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(bath_towel.0)\", \"soaked(bath_towel.0)\", \"not dusty(room_floor_bathroom.0) and not stained(room_floor_bathroom.0)\"]}"
    },
    "washing_pots_and_pans": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: washing_pots_and_pans\n## Relevant objects in this scene\n{'name': 'teapot.78', 'category': 'teapot_n_01'}\n{'name': 'kettle.79', 'category': 'kettle_n_01'}\n{'name': 'saucepan.80', 'category': 'pan_n_01'}\n{'name': 'saucepan.81', 'category': 'pan_n_01'}\n{'name': 'frying_pan.82', 'category': 'pan_n_01'}\n{'name': 'countertop.31', 'category': 'countertop_n_01'}\n{'name': 'countertop.33', 'category': 'countertop_n_01'}\n{'name': 'sink.37', 'category': 'sink_n_01'}\n{'name': 'scrub_brush.83', 'category': 'scrub_brush_n_01'}\n{'name': 'soap.84', 'category': 'soap_n_01'}\n{'name': 'top_cabinet.27', 'category': 'cabinet_n_01'}\n{'name': 'bottom_cabinet_no_top.32', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\nontop(teapot.78, countertop.31)\nstained(teapot.78)\nontop(kettle.79, countertop.33)\nstained(kettle.79)\nontop(saucepan.80, countertop.31)\nstained(saucepan.80)\nontop(saucepan.81, countertop.31)\nstained(saucepan.81)\nontop(frying_pan.82, countertop.33)\nstained(frying_pan.82)\nontop(scrub_brush.83, countertop.33)\nsoaked(scrub_brush.83)\ninside(soap.84, sink.37)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(pan_n_01, ((not stained(pan_n_01)) and exists(cabinet_n_01, inside(pan_n_01, cabinet_n_01))))\nforall(kettle_n_01, ((not stained(kettle_n_01)) and exists(cabinet_n_01, inside(kettle_n_01, cabinet_n_01))))\nforall(teapot_n_01, ((not stained(teapot_n_01)) and exists(cabinet_n_01, inside(teapot_n_01, cabinet_n_01))))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(scrub_brush.83)\", \"not stained(teapot.78) and not stained(kettle.79) and not stained(saucepan.80) and not stained(saucepan.81) and not stained(frying_pan.82)\", \"inside(teapot.78, top_cabinet.27)\", \"inside(kettle.79, top_cabinet.27)\", \"inside(saucepan.80, bottom_cabinet_no_top.32)\", \"inside(saucepan.81, bottom_cabinet_no_top.32)\", \"inside(frying_pan.82, bottom_cabinet_no_top.32)\"]}"
    },
    "watering_houseplants": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: watering_houseplants\n## Relevant objects in this scene\n{'name': 'pot_plant.0', 'category': 'pot_plant_n_01'}\n{'name': 'pot_plant.1', 'category': 'pot_plant_n_01'}\n{'name': 'pot_plant.2', 'category': 'pot_plant_n_01'}\n{'name': 'room_floor_dining_room.0', 'category': 'floor_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n{'name': 'sink.64', 'category': 'sink_n_01'}\n{'name': 'breakfast_table.16', 'category': 'table_n_02'}\n{'name': 'countertop.56', 'category': 'countertop_n_01'}\n\n## Initial States\nonfloor(pot_plant.0, room_floor_dining_room.0)\nonfloor(pot_plant.1, room_floor_dining_room.0)\nonfloor(pot_plant.2, room_floor_kitchen.0)\nnot soaked(pot_plant.0)\nnot soaked(pot_plant.1)\nnot soaked(pot_plant.2)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nforall(pot_plant_n_01, soaked(pot_plant_n_01))\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\n  \"output\": [\n    \"ontop(pot_plant.0, countertop.56) and ontop(pot_plant.1, countertop.56) and ontop(pot_plant.2, countertop.56)\",\n    \"holds_rh(pot_plant.0)\",\n    \"inside(pot_plant.0, sink.64) and toggledon(sink.64)\",\n    \"soaked(pot_plant.0)\",\n    \"not holds_rh(pot_plant.0) and holds_rh(pot_plant.1)\",\n    \"inside(pot_plant.1, sink.64)\",\n    \"soaked(pot_plant.1)\",\n    \"not holds_rh(pot_plant.1) and holds_rh(pot_plant.2)\",\n    \"inside(pot_plant.2, sink.64)\",\n    \"soaked(pot_plant.2)\"\n  ]\n}"
    },
    "waxing_cars_or_other_vehicles": {
        "system_input": "# Background Introduction\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states (which is called subgoals as a whole) to achieve the final goal states from the initial states. The output consists of a list of boolean expression, which is a combination of the state predicates. Note that your output boolean expression list is in temporal order, therefore, it must be consistent and logical. In short, your task is to output the subgoal plan in the required format.\n\n# Data Vocabulary Introduction\nBelow we introduce the detailed data vocabulary and their format that you can use to generate the subgoal plan.\n## Available States\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. An example is \"inside(coin.1, jar.1)\". Below is a list of available states and their descriptions.\n| State Name | Arguments | Description |\n| --- | --- | --- |\n| inside | (obj1.id, obj2.id) | obj1 is inside obj2. If we have state inside(A, B), and you want to take A out of B while B is openable and stayed at \"not open\" state, please open B first. Also, inside(obj1, agent) is invalid.|\n| ontop | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| nextto | (obj1.id, obj2.id) | obj1 is next to obj2 |\n| under | (obj1.id, obj2.id) | obj1 is under obj2 |\n| onfloor | (obj1.id, floor2.id) | obj1 is on the floor2 |\n| touching | (obj1.id, obj2.id) | obj1 is touching or next to obj2 |\n| cooked | (obj1.id) | obj1 is cooked |\n| burnt | (obj1.id) | obj1 is burnt |\n| dusty | (obj1.id) | obj1 is dusty. If want to change dusty(obj1.id) to \"not dusty(obj1.id)\", there are two ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, dishwasher or sink), toggledon(dishwasher or sink)] 2. holding other cleanning tool |\n| frozen | (obj1.id) | obj1 is frozen |\n| open | (obj1.id) | obj1 is open |\n| sliced | (obj1.id) | obj1 is sliced. If want to change \"not sliced(obj1.id)\" to \"sliced(obj1.id)\", one must have a slicer. | \n| soaked | (obj1.id) | obj1 is soaked |\n| stained | (obj1.id) | obj1 is stained. If want to change stained(obj1.id) to \"not stained(obj1.id)\", there are three ways to do it, depending on task conditions. Here, all objects other than obj1 are types but not instances: 1. [inside(obj1.id, sink), toggledon(sink)] 2. [soaked(cleaner)] 3. holding detergent. |\n| toggledon | (obj1.id) | obj1 is toggled on |\n| holds_rh | (obj1.id) | obj1 is in the right hand of the robot |\n| holds_lh | (obj1.id) | obj1 is in the left hand of the robot |\n## Available Connectives\nThe connectives are used to satisfy the complex conditions. They are used to combine the state predicates.\n| Connective Name | Arguments | Description |\n| --- | --- | --- |\n| and | exp1 and exp2 | evaluates to true if both exp1 and exp2 are true |\n| or | exp1 or exp2 | evaluates to true if either exp1 or exp2 is true |\n| not | not exp | evaluates to true if exp is false |\n| forall | forall(x, exp) | evaluates to true if exp is true for all x |\n| exists | exists(x, exp) | evaluates to true if exp is true for at least one x |\n| forpairs | forpairs(x, y, exp) | evaluates to true if exp is true for all pairs of x and y. For example, forpairs(watch, basket, inside(watch, basket)) means that for each watch and basket, the watch is inside the basket. |\n| forn | forn(n, x, exp) | evaluates to true if exp is true for exactly n times for x. For example, forn(2, jar_n_01, (not open(jar_n_01)) means that there are exactly two jars that are not open. |\n| fornpairs | fornpairs(n, x, y, exp) | evaluates to true if exp is true for exactly n times for pairs of x and y. For example, fornpairs(2, watch, basket, inside(watch, basket)) means that there are exactly two watches inside the basket. |\n\n# Rules You Must Follow\n- The initial states are the states that are given at the beginning of the task.\n- Your output must be a list of boolean expressions that are in temporal order.\n- You must follow the data format and the available states and connectives defined above.\n- The output must be consistent, logical and as detailed as possible. View your output as a complete state transition from the initial states to the final goal states.\n\n- Please note that the robot can only hold one object in one hand. Also, the robot needs to have at least one hand free to perform any action other than put, place, take, hold.\n- Use holds_rh and holds_lh in your plan if necessary. For example, stained(shoe) cannot directly change to not stained(shoe), but needs intermediate states like [soaked(rag), holds_rh(rag), not stained(shoe)] or [holds_rh(detergent), not stained(shoe)].\n- Your output follows the temporal order line by line. If you think there is no temporal order requirement for certain states, you can use connective 'and' to combine them. If you think some states are equivalent, you can use connective 'or' to combine them.\n- Please use provided relevant objects well to help you achieve the final goal states. Note that inside(obj1, agent) is an invalid state, therefore you cannot output it in your plan.\n- Do not output redundant states. A redundant state means a state that is either not necessary or has been satisfied before without broken. \n- Your must strictly follow the json format like this {\"output\": [<your subgoal plan>]}, where <your subgoal plan> is a list of boolean expressions presented in the temporal order.\n- Start your output with \"{\" and end with \"}\". For each line of the output,  DO NOT INCLUDE IRRELEVANT INFORMATION (like number of line, explanation, etc.).\n\n# Example: Task is bottling_fruit\nBelow we provide an example for your better understanding.\n## Relevant objects in this scene\n{'name': 'strawberry.0', 'category': 'strawberry_n_01'}\n{'name': 'fridge.97', 'category': 'electric_refrigerator_n_01'}\n{'name': 'peach.0', 'category': 'peach_n_03'}\n{'name': 'countertop.84', 'category': 'countertop_n_01'}\n{'name': 'jar.0', 'category': 'jar_n_01'}\n{'name': 'jar.1', 'category': 'jar_n_01'}\n{'name': 'carving_knife.0', 'category': 'carving_knife_n_01'}\n{'name': 'bottom_cabinet_no_top.80', 'category': 'cabinet_n_01'}\n{'name': 'room_floor_kitchen.0', 'category': 'floor_n_01'}\n\n## Initial States\ninside(strawberry.0, fridge.97)\ninside(peach.0, fridge.97)\nnot sliced(strawberry.0)\nnot sliced(peach.0)\nontop(jar.0, countertop.84)\nontop(jar.1, countertop.84)\nontop(carving_knife.0, countertop.84)\nonfloor(agent_n_01.1, room_floor_kitchen.0)\n\n## Goal States\nexists(jar_n_01, (inside(strawberry.0, jar_n_01) and (not inside(peach.0, jar_n_01))))\nexists(jar_n_01, (inside(peach.0, jar_n_01) and (not inside(strawberry.0, jar_n_01))))\nforall(jar_n_01, (not open(jar_n_01)))\nsliced(strawberry.0)\nsliced(peach.0)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\". \n{\"output\": [\"ontop(strawberry.0, countertop.84) and ontop(peach.0, countertop.84)\", \"holds_rh(carving_knife.0)\", \"sliced(strawberry.0) and sliced(peach.0)\", \"inside(strawberry.0, jar.0) and not inside(peach.0, jar.0)\", \"inside(peach.0, jar.1) and not inside(strawberry.0, jar.1)\", \"not open(jar.0) and not open(jar.1)\"]}",
        "user_input": "Now, it is time for you to generate the subgoal plan for the following task.\n# Target Task: waxing_cars_or_other_vehicles\n## Relevant objects in this scene\n{'name': 'car.50', 'category': 'vehicle_n_01'}\n{'name': 'room_floor_garage.0', 'category': 'floor_n_01'}\n{'name': 'cruet.51', 'category': 'vessel_n_03'}\n{'name': 'shelf.16', 'category': 'shelf_n_01'}\n{'name': 'rag.52', 'category': 'rag_n_01'}\n\n## Initial States\nonfloor(car.50, room_floor_garage.0)\ndusty(car.50)\nontop(cruet.51, shelf.16)\ninside(rag.52, shelf.16)\nonfloor(agent_n_01.1, room_floor_garage.0)\n\n## Goal States\nnot dusty(car.50)\n\n## Output: Based on initial states in this task, achieve final goal states logically and reasonably. It does not matter which state should be satisfied first, as long as all goal states can be satisfied at the end. Make sure your output follows the json format, and do not include irrelevant information, do not include any explanation. Output concrete states and do not use quantifiers like \"forall\" or \"exists\".",
        "output": "{\"output\": [\"holds_rh(rag.52)\", \"not dusty(car.50)\"]}"
    }
}